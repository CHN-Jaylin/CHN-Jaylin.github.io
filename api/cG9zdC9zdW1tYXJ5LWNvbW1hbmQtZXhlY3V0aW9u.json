{"title":"PHP中的命令执行","date":"2018-09-18T11:44:31.000Z","slug":"summary-command-execution","tags":["Php","Web"],"updated":"2018-09-19T11:23:21.296Z","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在 PHP 中, <code>exec()</code>、<code>system()</code>、<code>popen()</code>、<code>passthru()</code>、<code>proc_open()</code>、<code>pcntl_exec()</code>、<code>shell_exec()</code>，还有反引号 ``包裹的内容，都可以用来执行系统命令。</p>\n<p>如果执行的命令参数是用户可控的，那么就会造成命令执行漏洞。</p>\n<p>下面是常见的函数描述：</p>\n<ul>\n<li><p>system()</p>\n<p>  输出并返回最后一行shell结果。 </p>\n</li>\n<li><p>exec()</p>\n<p>  不输出结果，返回最后一行shell结果，所有结果可以保存到一个返回的数组里面。</p>\n</li>\n<li><p>passthru()</p>\n<p>  只调用命令，把命令的运行结果原样地直接输出到标准输出设备上。</p>\n</li>\n<li><p>popen()、proc_open()</p>\n<p>  不会直接返回执行结果，而是返回一个文件指针。</p>\n</li>\n<li><p>反引号</p>\n<p>  调用 <code>shell_exec()</code> 函数</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"各平台的漏洞利用\"><a href=\"#各平台的漏洞利用\" class=\"headerlink\" title=\"各平台的漏洞利用\"></a>各平台的漏洞利用</h2><p>在实际场景中，要利用命令执行漏洞，通常需要借助管道符，拼接到正常的命令参数中来实现。</p>\n<p>各个平台支持的管道符都有所不同，下面是 <code>Windows</code> 及 <code>Linux</code> 支持的管道符。</p>\n<h3 id=\"Windows\"><a href=\"#Windows\" class=\"headerlink\" title=\"Windows\"></a>Windows</h3><ul>\n<li><p>|</p>\n<p>  直接执行后面的语句。</p>\n<blockquote>\n<p>ping | whoami</p>\n</blockquote>\n</li>\n<li><p>||</p>\n<p>  如果前面的语句执行出错，则执行后面的语句。</p>\n<blockquote>\n<p>p || whoami</p>\n</blockquote>\n</li>\n<li><p>\\&amp;</p>\n<p>  如果前面的语句为假，直接执行后面的语句。</p>\n<p>  为真，也会执行后面的语句。</p>\n<blockquote>\n<p>ping 127.0.0.1 &amp; whoami</p>\n</blockquote>\n</li>\n<li><p>\\&amp;\\&amp;</p>\n<p>  如果前面的语句为假直接出错，不会执行后面的。前面的语句必须为真。</p>\n<blockquote>\n<p>ping 127.0.0.1 &amp;&amp; whoami</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h3><ul>\n<li><p>\\;</p>\n<p>  执行完前面的语句，再执行后面的。</p>\n<blockquote>\n<p>ping 127.0.0.1;whoami</p>\n</blockquote>\n</li>\n<li><p>|</p>\n<p>  直接执行后面的语句。</p>\n<blockquote>\n<p>ping | whoami</p>\n</blockquote>\n</li>\n<li><p>||</p>\n<p>  如果前面的语句执行出错，则执行后面的语句。</p>\n<blockquote>\n<p>p || whoami</p>\n</blockquote>\n</li>\n<li><p>\\&amp;</p>\n<p>  如果前面的语句为假，直接执行后面的语句。</p>\n<p>  为真，也会执行后面的语句。</p>\n<blockquote>\n<p>ping 127.0.0.1 &amp; whoami</p>\n</blockquote>\n</li>\n<li><p>\\&amp;\\&amp;</p>\n<p>  如果前面的语句为假直接出错，不会执行后面的。前面的语句必须为真。</p>\n<blockquote>\n<p>ping 127.0.0.1 &amp;&amp; whoami</p>\n</blockquote>\n</li>\n</ul>\n<hr>\n<h2 id=\"防御方法\"><a href=\"#防御方法\" class=\"headerlink\" title=\"防御方法\"></a>防御方法</h2><p>PHP 内置了两个函数，<code>escapeshellarg()</code>，<code>escapeshellcmd()</code>可以防止命令执行。</p>\n<ol>\n<li><p>escapeshellarg()</p>\n<p> 把字符串转码为可以在 shell 命令里使用的参数。</p>\n</li>\n<li><p>escapeshellcmd()</p>\n<p> shell 元字符转义。</p>\n<p> 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到 <code>exec()</code> 或 <code>system()</code> 函数，或者 执行操作符 之前进行转义。</p>\n<p> 反斜线（\\）会在以下字符之前插入： &amp;#;`|*?~&lt;&gt;^()[]{}$\\, \\x0A 和 \\xFF。 ‘ 和 “ 仅在不配对儿的时候被转义。 在 Windows 平台上，所有这些字符以及 % 和 ! 字符都会被空格代替。</p>\n</li>\n</ol>\n","prev":{"title":"当SQL注入遇到WAF","slug":"summary-sqli-bypass"},"next":{"title":"文件上传绕过的各种姿势","slug":"summary-fileupload-bypass"},"link":"http://Jayl1n.github.io/post/summary-command-execution/","toc":[{"title":"前言","id":"前言","index":"1"},{"title":"各平台的漏洞利用","id":"各平台的漏洞利用","index":"2","children":[{"title":"Windows","id":"Windows","index":"2.1"},{"title":"Linux","id":"Linux","index":"2.2"}]},{"title":"防御方法","id":"防御方法","index":"3"}]}